<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Objective-C - Runtime 总结梳理" /><meta name="author" content="Ouyang Rong" /><meta property="og:locale" content="en_US" /><meta name="description" content="Runtime的特性主要是消息(方法)传递，如果消息(方法)在对象中找不到，就进行转发，具体怎么实现的呢。我们从下面几个方面探寻Runtime的实现机制。" /><meta property="og:description" content="Runtime的特性主要是消息(方法)传递，如果消息(方法)在对象中找不到，就进行转发，具体怎么实现的呢。我们从下面几个方面探寻Runtime的实现机制。" /><link rel="canonical" href="https://ouyangrong.com/posts/iOS-Runtime-Summary/" /><meta property="og:url" content="https://ouyangrong.com/posts/iOS-Runtime-Summary/" /><meta property="og:site_name" content="Ouyang Rong" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-10-27T18:11:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Objective-C - Runtime 总结梳理" /><meta name="twitter:site" content="@ouyangrong1313" /><meta name="twitter:creator" content="@Ouyang Rong" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Ouyang Rong"},"dateModified":"2021-10-28T13:47:54+08:00","datePublished":"2021-10-27T18:11:00+08:00","description":"Runtime的特性主要是消息(方法)传递，如果消息(方法)在对象中找不到，就进行转发，具体怎么实现的呢。我们从下面几个方面探寻Runtime的实现机制。","headline":"Objective-C - Runtime 总结梳理","mainEntityOfPage":{"@type":"WebPage","@id":"https://ouyangrong.com/posts/iOS-Runtime-Summary/"},"url":"https://ouyangrong.com/posts/iOS-Runtime-Summary/"}</script><title>Objective-C - Runtime 总结梳理 | Ouyang Rong</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Ouyang Rong"><meta name="application-name" content="Ouyang Rong"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-4EXCTKYR2M"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-4EXCTKYR2M'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/images/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Ouyang Rong</a></div><div class="site-subtitle font-italic">Stay Hungry, Stay Foolish.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/ouyangrong1313" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/ouyangrong1313" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['951607559','qq.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Objective-C - Runtime 总结梳理</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Objective-C - Runtime 总结梳理</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Ouyang Rong </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Oct 27, 2021, 6:11 PM +0800" prep="on" > Oct 27, 2021 <i class="unloaded">2021-10-27T18:11:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Oct 28, 2021, 1:47 PM +0800" prefix="Updated " > Oct 28, 2021 <i class="unloaded">2021-10-28T13:47:54+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7277 words">40 min</span></div></div><div class="post-content"><p><code class="language-plaintext highlighter-rouge">Runtime</code>的特性主要是消息(方法)传递，如果消息(方法)在对象中找不到，就进行转发，具体怎么实现的呢。我们从下面几个方面探寻<code class="language-plaintext highlighter-rouge">Runtime</code>的实现机制。</p><h1 id="runtime介绍">Runtime介绍</h1><p><code class="language-plaintext highlighter-rouge">Objective-C</code> 扩展了 <code class="language-plaintext highlighter-rouge">C</code> 语言，并加入了面向对象特性和 <code class="language-plaintext highlighter-rouge">Smalltalk</code> 式的消息传递机制。而这个扩展的核心是一个用 <code class="language-plaintext highlighter-rouge">C</code> 和编译语言写的 <code class="language-plaintext highlighter-rouge">Runtime</code> 库。它是 <code class="language-plaintext highlighter-rouge">Objective-C</code> 面向对象和动态机制的基石。</p><p><code class="language-plaintext highlighter-rouge">Objective-C</code> 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 <code class="language-plaintext highlighter-rouge">Objective-C</code> 的 <code class="language-plaintext highlighter-rouge">Runtime</code> 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。</p><p><code class="language-plaintext highlighter-rouge">Runtime</code> 其实有两个版本: “<code class="language-plaintext highlighter-rouge">modern</code>” 和 “<code class="language-plaintext highlighter-rouge">legacy</code>”。我们现在用的 <code class="language-plaintext highlighter-rouge">Objective-C 2.0</code> 采用的是现行 (<code class="language-plaintext highlighter-rouge">Modern</code>) 版的 <code class="language-plaintext highlighter-rouge">Runtime</code> 系统，只能运行在 iOS 和 macOS 10.5 之后的64位程序中。而 macOS 较老的32位程序仍采用 <code class="language-plaintext highlighter-rouge">Objective-C 1.0</code> 中的（早期）<code class="language-plaintext highlighter-rouge">Legacy</code> 版本的 <code class="language-plaintext highlighter-rouge">Runtime</code> 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。</p><p><code class="language-plaintext highlighter-rouge">Runtime</code> 基本是用 <code class="language-plaintext highlighter-rouge">C</code> 和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在<a href="https://opensource.apple.com/source/objc4/">这里</a>下到苹果维护的开源代码。苹果和GNU各自维护一个开源的 <a href="https://github.com/RetVal/objc-runtime">runtime</a> 版本，这两个版本之间都在努力的保持一致。平时的业务中主要是使用<a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime?language=objc">官方Api</a>，解决我们框架性的需求。</p><p>高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但是 <code class="language-plaintext highlighter-rouge">OC</code> 并不能直接编译为汇编语言，而是要先转写为纯 <code class="language-plaintext highlighter-rouge">C</code> 语言再进行编译和汇编的操作，从 <code class="language-plaintext highlighter-rouge">OC</code> 到 <code class="language-plaintext highlighter-rouge">C</code> 语言的过渡就是由 <code class="language-plaintext highlighter-rouge">Runtime</code> 来实现的。然而我们使用 <code class="language-plaintext highlighter-rouge">OC</code> 进行面向对象开发，而 <code class="language-plaintext highlighter-rouge">C</code> 语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。</p><h1 id="runtime消息传递">Runtime消息传递</h1><p>一个对象的方法像这样<code class="language-plaintext highlighter-rouge">[obj foo]</code>，编译器转成消息发送<code class="language-plaintext highlighter-rouge">objc_msgSend(obj, foo)</code>，如果消息含有参数，则为：<code class="language-plaintext highlighter-rouge">objc_msgSend(receiver, selector, arg1, arg2, ...)</code>。</p><p><code class="language-plaintext highlighter-rouge">Runtime</code>时执行的流程是这样的：</p><ul><li>首先，通过 <code class="language-plaintext highlighter-rouge">obj</code> 的 <code class="language-plaintext highlighter-rouge">isa</code> 指针找到它的 <code class="language-plaintext highlighter-rouge">class</code>;<li>在 <code class="language-plaintext highlighter-rouge">class</code> 的 <code class="language-plaintext highlighter-rouge">method list</code> 找 <code class="language-plaintext highlighter-rouge">foo</code> ;<li>如果 <code class="language-plaintext highlighter-rouge">class</code> 中没到 <code class="language-plaintext highlighter-rouge">foo</code>，继续往它的 <code class="language-plaintext highlighter-rouge">superclass</code> 中找 ;<li>一旦找到 <code class="language-plaintext highlighter-rouge">foo</code> 这个函数，就去执行它的实现 <code class="language-plaintext highlighter-rouge">IMP</code>。</ul><p><code class="language-plaintext highlighter-rouge">objec_msgSend</code>的方法定义如下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>OBJC_EXPORT id objc_msgSend(id self, SEL op, ...)
</pre></table></code></div></div><p>那消息传递是怎么实现的呢？我们看看对象(object)，类(class)，方法(method)这几个的结构体：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre>//对象
struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
};
//类
struct objc_class {
    Class isa  OBJC_ISA_AVAILABILITY;
#if !__OBJC2__
    Class super_class                                        OBJC2_UNAVAILABLE;
    const char *name                                         OBJC2_UNAVAILABLE;
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
#endif
} OBJC2_UNAVAILABLE;
//方法列表
struct objc_method_list {
    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;
    int method_count                                         OBJC2_UNAVAILABLE;
#ifdef __LP64__
    int space                                                OBJC2_UNAVAILABLE;
#endif
    /* variable length structure */
    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;
}                                                            OBJC2_UNAVAILABLE;
//方法
struct objc_method {
    SEL method_name                                          OBJC2_UNAVAILABLE;
    char *method_types                                       OBJC2_UNAVAILABLE;
    IMP method_imp                                           OBJC2_UNAVAILABLE;
}
</pre></table></code></div></div><ol><li>系统首先找到消息的接收对象，然后通过对象的<code class="language-plaintext highlighter-rouge">isa</code>找到它的类。<li>在它的类中查找<code class="language-plaintext highlighter-rouge">method_list</code>，是否有<code class="language-plaintext highlighter-rouge">selector</code>方法。<li>没有则查找父类的<code class="language-plaintext highlighter-rouge">method_list</code>。<li>找到对应的<code class="language-plaintext highlighter-rouge">method</code>，执行它的<code class="language-plaintext highlighter-rouge">IMP</code>。<li>转发<code class="language-plaintext highlighter-rouge">IMP</code>的<code class="language-plaintext highlighter-rouge">return</code>值。</ol><p><strong>下面讲讲消息传递用到的一些概念</strong>：</p><ul><li>类对象(objc_class)<li>实例(objc_object)<li>元类(Meta Class)<li>Method(objc_method)<li>SEL(objc_selector)<li>IMP<li>类缓存(objc_cache)<li>Category(objc_category)</ul><h2 id="类对象objc_class">类对象(objc_class)</h2><p><code class="language-plaintext highlighter-rouge">Objective-C</code> 类是由 <code class="language-plaintext highlighter-rouge">Class</code> 类型来表示的，它实际上是一个指向 <code class="language-plaintext highlighter-rouge">objc_class</code> 结构体的指针。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>typedef struct objc_class *Class;
</pre></table></code></div></div><p>查看<code class="language-plaintext highlighter-rouge">objc/runtime.h</code>中<code class="language-plaintext highlighter-rouge">objc_class</code>结构体的定义如下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>struct objc_class {
    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    Class _Nullable super_class                              OBJC2_UNAVAILABLE;
    const char * _Nonnull name                               OBJC2_UNAVAILABLE;
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;
    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;
    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;
#endif

} OBJC2_UNAVAILABLE;
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">struct objc_class</code>结构体定义了很多变量，通过命名不难发现，结构体里保存了指向父类的指针、类的名字、版本、实例大小、实例变量列表、方法列表、缓存、遵守的协议列表等，一个类包含的信息也不就正是这些吗？没错，类对象就是一个结构体<code class="language-plaintext highlighter-rouge">struct objc_class</code>，这个结构体存放的数据称为元数据(metadata)，该结构体的第一个成员变量也是<code class="language-plaintext highlighter-rouge">isa</code>指针，这就说明了<code class="language-plaintext highlighter-rouge">Class</code>本身其实也是一个对象，因此我们称之为类对象，类对象在编译期产生用于创建实例对象，是单例。</p><h2 id="实例objc_object">实例(objc_object)</h2><p><code class="language-plaintext highlighter-rouge">objc_msgSend</code> 第一个参数类型为<code class="language-plaintext highlighter-rouge">id</code>，大家对它都不陌生，它是一个指向类实例的指针：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>/// Represents an instance of a class.
struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
};

/// A pointer to an instance of a class.
typedef struct objc_object *id;
</pre></table></code></div></div><p>那 <code class="language-plaintext highlighter-rouge">objc_object</code> 又是啥呢，参考 <code class="language-plaintext highlighter-rouge">objc-private.h</code> 文件部分源码：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>struct objc_object {
private:
    isa_t isa;

public:

    // ISA() assumes this is NOT a tagged pointer object
    Class ISA();

    // getIsa() allows this to be a tagged pointer object
    Class getIsa();
    ... 此处省略其他方法声明
}
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">objc_object</code> 结构体包含一个 <code class="language-plaintext highlighter-rouge">isa</code> 指针，类型为 <code class="language-plaintext highlighter-rouge">isa_t</code> 联合体。根据 <code class="language-plaintext highlighter-rouge">isa</code> 就可以顺藤摸瓜找到对象所属的类。<code class="language-plaintext highlighter-rouge">isa</code> 这里还涉及到 <code class="language-plaintext highlighter-rouge">tagged pointer</code> 等概念。因为 <code class="language-plaintext highlighter-rouge">isa_t</code> 使用 <code class="language-plaintext highlighter-rouge">union</code> 实现，所以可能表示多种形态，既可以当成是指针，也可以存储标志位。有关 <code class="language-plaintext highlighter-rouge">isa_t</code> 联合体的更多内容可以查看 <a href="http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/#isa-指针（NONPOINTER-ISA）">Objective-C 引用计数原理</a>。</p><p>PS: <code class="language-plaintext highlighter-rouge">isa</code> 指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用 <code class="language-plaintext highlighter-rouge">class</code> 方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的 <code class="language-plaintext highlighter-rouge">isa</code> 指针指向一个中间类而不是真实的类，这是一种叫做 <code class="language-plaintext highlighter-rouge">isa-swizzling</code> 的技术，详见<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html">官方文档</a></p><p>类对象中的元数据存储的都是如何创建一个实例的相关信息，那么类对象和类方法应该从哪里创建呢？ 就是从 <code class="language-plaintext highlighter-rouge">isa</code> 指针指向的结构体创建，类对象的 <code class="language-plaintext highlighter-rouge">isa</code> 指针指向的我们称之为元类(metaclass)， 元类中保存了创建类对象以及类方法所需的所有信息，因此整个结构应该如下图所示:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/Runtime%20-%20%E7%B1%BB%E5%AF%B9%E8%B1%A1.png" alt="" /></p><h2 id="元类meta-class">元类(Meta Class)</h2><p>通过上图我们可以看出整个体系构成了一个自闭环，<code class="language-plaintext highlighter-rouge">struct objc_object</code>结构体实例它的<code class="language-plaintext highlighter-rouge">isa</code>指针指向类对象， 类对象的<code class="language-plaintext highlighter-rouge">isa</code>指针指向了元类，<code class="language-plaintext highlighter-rouge">super_class</code>指针指向了父类的类对象， 而元类的<code class="language-plaintext highlighter-rouge">super_class</code>指针指向了父类的元类，那元类的<code class="language-plaintext highlighter-rouge">isa</code>指针又指向了自己。</p><p>元类(Meta Class)是一个类对象的类。 在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。 为了调用类方法，这个类的<code class="language-plaintext highlighter-rouge">isa</code>指针必须指向一个包含这些类方法的一个<code class="language-plaintext highlighter-rouge">objc_class</code>结构体。这就引出了<code class="language-plaintext highlighter-rouge">meta-class</code>的概念，元类中保存了创建类对象以及类方法所需的所有信息。 任何<code class="language-plaintext highlighter-rouge">NSObject</code>继承体系下的<code class="language-plaintext highlighter-rouge">meta-class</code>都使用<code class="language-plaintext highlighter-rouge">NSObject</code>的<code class="language-plaintext highlighter-rouge">meta-class</code>作为自己的所属类，而基类的<code class="language-plaintext highlighter-rouge">meta-class</code>的<code class="language-plaintext highlighter-rouge">isa</code>指针是指向它自己。</p><h2 id="methodobjc_method">Method(objc_method)</h2><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>runtime.h
/// An opaque type that represents a method in a class definition. 代表类定义中一个方法的不透明类型
typedef struct objc_method *Method;
struct objc_method {
    SEL method_name                                          OBJC2_UNAVAILABLE;
    char *method_types                                       OBJC2_UNAVAILABLE;
    IMP method_imp                                           OBJC2_UNAVAILABLE;
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Method</code>和我们平时理解的函数是一致的，就是表示能够独立完成一个功能的一段代码，比如：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>- (void)logName
{
	NSLog(@"name");
}
</pre></table></code></div></div><p>这段代码，就是一个函数。 我们来看下<code class="language-plaintext highlighter-rouge">objc_method</code>这个结构体的内容：</p><ul><li><code class="language-plaintext highlighter-rouge">SEL method_name</code> 方法名<li><code class="language-plaintext highlighter-rouge">char *method_types</code> 方法类型<li><code class="language-plaintext highlighter-rouge">IMP method_imp</code> 方法实现</ul><p>在这个结构体重，我们已经看到了<code class="language-plaintext highlighter-rouge">SEL</code>和<code class="language-plaintext highlighter-rouge">IMP</code>，说明<code class="language-plaintext highlighter-rouge">SEL</code>和<code class="language-plaintext highlighter-rouge">IMP</code>其实都是<code class="language-plaintext highlighter-rouge">Method</code>的属性。</p><p>我们接着来看<code class="language-plaintext highlighter-rouge">SEL</code>。</p><h2 id="selobjc_selector">SEL(objc_selector)</h2><p>先看下定义</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>Objc.h
/// An opaque type that represents a method selector.代表一个方法的不透明类型
typedef struct objc_selector *SEL;
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">objc_msgSend</code>函数第二个参数类型为<code class="language-plaintext highlighter-rouge">SEL</code>，它是<code class="language-plaintext highlighter-rouge">selector</code>在<code class="language-plaintext highlighter-rouge">Objective-C</code>中的表示类型（<code class="language-plaintext highlighter-rouge">Swift</code>中是<code class="language-plaintext highlighter-rouge">Selector</code>类）。<code class="language-plaintext highlighter-rouge">selector</code>是方法选择器，可以理解为区分方法的<code class="language-plaintext highlighter-rouge">ID</code>，而这个<code class="language-plaintext highlighter-rouge">ID</code>的数据结构是<code class="language-plaintext highlighter-rouge">SEL</code>:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>@property SEL selector;
</pre></table></code></div></div><p>可以看到<code class="language-plaintext highlighter-rouge">selector</code>是<code class="language-plaintext highlighter-rouge">SEL</code>的一个实例。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded.
</pre></table></code></div></div><p>其实<code class="language-plaintext highlighter-rouge">selector</code>就是个映射到方法的<code class="language-plaintext highlighter-rouge">C</code>字符串，你可以用 <code class="language-plaintext highlighter-rouge">Objective-C</code> 编译器命令<code class="language-plaintext highlighter-rouge">@selector()</code>或者 <code class="language-plaintext highlighter-rouge">Runtime</code> 系统的<code class="language-plaintext highlighter-rouge">sel_registerName</code>函数来获得一个 <code class="language-plaintext highlighter-rouge">SEL</code> 类型的方法选择器。</p><p><code class="language-plaintext highlighter-rouge">selector</code>既然是一个<code class="language-plaintext highlighter-rouge">string</code>，我觉得应该是类似<code class="language-plaintext highlighter-rouge">className+method</code>的组合，命名规则有两条：</p><ul><li>同一个类，<code class="language-plaintext highlighter-rouge">selector</code>不能重复<li>不同的类，<code class="language-plaintext highlighter-rouge">selector</code>可以重复</ul><p>这也带来了一个弊端，我们在写<code class="language-plaintext highlighter-rouge">C</code>代码的时候，经常会用到函数重载，就是函数名相同，参数不同，但是这在<code class="language-plaintext highlighter-rouge">Objective-C</code>中是行不通的，因为<code class="language-plaintext highlighter-rouge">selector</code>只记了<code class="language-plaintext highlighter-rouge">method</code>的<code class="language-plaintext highlighter-rouge">name</code>，没有参数，所以没法区分不同的<code class="language-plaintext highlighter-rouge">method</code>。</p><p>比如：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>- (void)caculate(NSInteger)num;
- (void)caculate(CGFloat)num;
</pre></table></code></div></div><p>是会报错的。</p><p>我们只能通过命名来区别：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>- (void)caculateWithInt(NSInteger)num;
- (void)caculateWithFloat(CGFloat)num;
</pre></table></code></div></div><p>在不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器。</p><h2 id="imp">IMP</h2><p>看下<code class="language-plaintext highlighter-rouge">IMP</code>的定义</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>/// A pointer to the function of a method implementation. 指向一个方法实现的指针
typedef id (*IMP)(id, SEL, ...);
#endif
</pre></table></code></div></div><p>就是指向最终实现程序的内存地址的指针。</p><p>在iOS的<code class="language-plaintext highlighter-rouge">Runtime</code>中，<code class="language-plaintext highlighter-rouge">Method</code>通过<code class="language-plaintext highlighter-rouge">selector</code>和<code class="language-plaintext highlighter-rouge">IMP</code>两个属性，实现了快速查询方法及实现，相对提高了性能，又保持了灵活性。</p><h2 id="类缓存objc_cache">类缓存(objc_cache)</h2><p>当<code class="language-plaintext highlighter-rouge">Objective-C</code>运行时通过跟踪它的<code class="language-plaintext highlighter-rouge">isa</code>指针检查对象时，它可以找到一个实现许多方法的对象。然而，你可能只调用它们的一小部分，并且每次查找时，搜索所有选择器的类分派表没有意义。所以类实现一个缓存，每当你搜索一个类分派表，并找到相应的选择器，它把它放入它的缓存。所以当<code class="language-plaintext highlighter-rouge">objc_msgSend</code>查找一个类的选择器，它首先搜索类缓存。这是基于这样的理论：如果你在类上调用一个消息，你可能以后再次调用该消息。</p><p>为了加速消息分发， 系统会对方法和对应的地址进行缓存，就放在上述的<code class="language-plaintext highlighter-rouge">objc_cache</code>，所以在实际运行中，大部分常用的方法都是会被缓存起来的，<code class="language-plaintext highlighter-rouge">Runtime</code>系统实际上非常快，接近直接执行内存地址的程序速度。</p><h2 id="categoryobjc_category">Category(objc_category)</h2><p><code class="language-plaintext highlighter-rouge">Category</code>是表示一个指向分类的结构体的指针，其定义如下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>struct category_t {
    const char *name;
    classref_t cls;
    struct method_list_t *instanceMethods;
    struct method_list_t *classMethods;
    struct protocol_list_t *protocols;
    struct property_list_t *instanceProperties;
};
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>name：是指 class_name 而不是 category_name。
cls：要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对 应到对应的类对象。
instanceMethods：category中所有给类添加的实例方法的列表。
classMethods：category中所有添加的类方法的列表。
protocols：category实现的所有协议的列表。
instanceProperties：表示Category里所有的properties，这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，不过这个和一般的实例变量是不一样的。
</pre></table></code></div></div><p>从上面的<code class="language-plaintext highlighter-rouge">category_t</code>的结构体中可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，不可以添加成员变量。</p><h1 id="runtime消息转发">Runtime消息转发</h1><p>前文介绍了进行一次发送消息会在相关的类对象中搜索方法列表，如果找不到则会沿着继承树向上一直搜索直到继承树根部（通常为<code class="language-plaintext highlighter-rouge">NSObject</code>），如果还是找不到并且消息转发都失败了就会执行<code class="language-plaintext highlighter-rouge">doesNotRecognizeSelector:</code>方法报<code class="language-plaintext highlighter-rouge">unrecognized selector</code>错。那么消息转发到底是什么呢？接下来将会逐一介绍最后的三次机会。</p><ul><li>动态方法解析<li>备用接收者<li>完整消息转发</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/Runtime%20-%20%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.png" alt="" /></p><h2 id="动态方法解析">动态方法解析</h2><p>首先，<code class="language-plaintext highlighter-rouge">Objective-C</code>运行时会调用 <code class="language-plaintext highlighter-rouge">+resolveInstanceMethod:</code> 或者 <code class="language-plaintext highlighter-rouge">+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数并返回<code class="language-plaintext highlighter-rouge">YES</code>， 那运行时系统就会重新启动一次消息发送的过程。</p><p>实现一个动态方法解析的例子如下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    // 执行foo函数
    [self performSelector:@selector(foo:)];
}

+ (BOOL)resolveInstanceMethod:(SEL)sel {
    if (sel == @selector(foo:)) { // 如果是执行foo函数，就动态解析，指定新的IMP
        class_addMethod([self class], sel, (IMP)fooMethod, "v@:");
        return YES;
    }
    return [super resolveInstanceMethod:sel];
}

void fooMethod(id obj, SEL _cmd) {
    NSLog(@"Doing foo"); // 新的foo函数
}
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>打印结果： 2018-04-01 12:23:35.952670+0800 ocram[87546:23235469] Doing foo
</pre></table></code></div></div><p>可以看到虽然没有实现<code class="language-plaintext highlighter-rouge">foo:</code>这个函数，但是我们通过<code class="language-plaintext highlighter-rouge">class_addMethod</code>动态添加<code class="language-plaintext highlighter-rouge">fooMethod</code>函数，并执行<code class="language-plaintext highlighter-rouge">fooMethod</code>这个函数的<code class="language-plaintext highlighter-rouge">IMP</code>。从打印结果看，成功实现了。</p><p>如果<code class="language-plaintext highlighter-rouge">resolve</code>方法返回<code class="language-plaintext highlighter-rouge">NO</code>，运行时就会移到下一步：<code class="language-plaintext highlighter-rouge">forwardingTargetForSelector</code>。</p><h2 id="备用接收者">备用接收者</h2><p>如果目标对象实现了<code class="language-plaintext highlighter-rouge">-forwardingTargetForSelector:</code>，<code class="language-plaintext highlighter-rouge">Runtime</code> 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。</p><p>实现一个备用接收者的例子如下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre>#import "ViewController.h"
#import "objc/runtime.h"

@interface Person: NSObject

@end

@implementation Person

- (void)foo {
    NSLog(@"Doing foo");//Person的foo函数
}

@end

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    // 执行foo函数
    [self performSelector:@selector(foo)];
}

+ (BOOL)resolveInstanceMethod:(SEL)sel {
    return [super resolveInstanceMethod:sel]; // 未处理，进入下一步转发
}

- (id)forwardingTargetForSelector:(SEL)aSelector {
    if (aSelector == @selector(foo)) {
        return [Person new]; // 返回Person对象，让Person对象接收这个消息
    }
    return [super forwardingTargetForSelector:aSelector];
}

@end
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>打印结果： 2018-04-01 12:45:04.757929+0800 ocram[88023:23260346] Doing foo
</pre></table></code></div></div><p>可以看到我们通过<code class="language-plaintext highlighter-rouge">forwardingTargetForSelector</code>把当前<code class="language-plaintext highlighter-rouge">ViewController</code>的方法转发给了<code class="language-plaintext highlighter-rouge">Person</code>去执行了。打印结果也证明我们成功实现了转发。</p><h2 id="完整消息转发">完整消息转发</h2><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。</p><p>首先它会发送 <code class="language-plaintext highlighter-rouge">-methodSignatureForSelector:</code> 消息获得函数的参数和返回值类型。如果 <code class="language-plaintext highlighter-rouge">-methodSignatureForSelector:</code> 返回 <code class="language-plaintext highlighter-rouge">nil</code>，<code class="language-plaintext highlighter-rouge">Runtime</code>则会发出 <code class="language-plaintext highlighter-rouge">-doesNotRecognizeSelector:</code> 消息，程序这时也就挂掉了。如果返回了一个函数签名，<code class="language-plaintext highlighter-rouge">Runtime</code> 就会创建一个 <code class="language-plaintext highlighter-rouge">NSInvocation</code> 对象并发送 <code class="language-plaintext highlighter-rouge">-forwardInvocation:</code> 消息给目标对象。</p><p>实现一个完整转发的例子如下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre><td class="rouge-code"><pre>#import "ViewController.h"
#import "objc/runtime.h"

@interface Person: NSObject

@end

@implementation Person

- (void)foo {
    NSLog(@"Doing foo");//Person的foo函数
}

@end

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    // 执行foo函数
    [self performSelector:@selector(foo)];
}

+ (BOOL)resolveInstanceMethod:(SEL)sel {
    return [super resolveInstanceMethod:sel]; // 未处理，进入下一步转发
}

- (id)forwardingTargetForSelector:(SEL)aSelector {
    return nil; // 返回nil，进入下一步转发
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
    if ([NSStringFromSelector(aSelector) isEqualToString:@"foo"]) {
        return [NSMethodSignature signatureWithObjCTypes:"v@:"]; // 签名，进入forwardInvocation
    }
    return [super methodSignatureForSelector:aSelector];
}

- (void)forwardInvocation:(NSInvocation *)anInvocation {
    SEL sel = anInvocation.selector;
    Person *p = [Person new];
    if([p respondsToSelector:sel]) {
        [anInvocation invokeWithTarget:p];
    }
    else {
        [self doesNotRecognizeSelector:sel];
    }
}

@end
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>打印结果： 2018-04-01 13:00:45.423385+0800 ocram[88353:23279961] Doing foo
</pre></table></code></div></div><p>从打印结果来看，我们实现了完整的转发。通过签名，<code class="language-plaintext highlighter-rouge">Runtime</code>生成了一个对象<code class="language-plaintext highlighter-rouge">anInvocation</code>，发送给了<code class="language-plaintext highlighter-rouge">forwardInvocation</code>，我们在<code class="language-plaintext highlighter-rouge">forwardInvocation</code>方法里面让<code class="language-plaintext highlighter-rouge">Person</code>对象去执行了<code class="language-plaintext highlighter-rouge">foo</code>函数。签名参数<code class="language-plaintext highlighter-rouge">v@:</code>怎么解释呢？这里苹果文档<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encodings</a>有详细的解释。</p><p>以上就是<code class="language-plaintext highlighter-rouge">Runtime</code>的三次转发流程。下面我们讲讲<code class="language-plaintext highlighter-rouge">Runtime</code>的实际应用。</p><h1 id="runtime应用">Runtime应用</h1><p>Runtime简直就是做大型框架的利器。它的应用场景非常多，下面就介绍一些常见的应用场景。</p><ul><li>关联对象(Objective-C Associated Objects)给分类增加属性<li>方法魔法(Method Swizzling)方法添加、替换和KVO实现<li>消息转发(热更新)解决Bug(JSPatch)<li>实现NSCoding的自动归档和自动解档<li>实现字典和模型的自动转换(MJExtension)</ul><h2 id="关联对象objective-c-associated-objects给分类增加属性">关联对象(Objective-C Associated Objects)给分类增加属性</h2><p>我们都是知道分类是不能自定义属性和变量的。下面通过关联对象实现给分类添加属性。</p><p>关联对象<code class="language-plaintext highlighter-rouge">Runtime</code>提供了下面几个接口：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>//关联对象
void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)
//获取关联的对象
id objc_getAssociatedObject(id object, const void *key)
//移除关联的对象
void objc_removeAssociatedObjects(id object)
</pre></table></code></div></div><p>参数解释</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>id object：被关联的对象
const void *key：关联的key，要求唯一
id value：关联的对象
objc_AssociationPolicy policy：内存管理的策略
</pre></table></code></div></div><p>内存管理的策略</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {
    OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object.
                                            *   The association is not made atomically. */
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied.
                                            *   The association is not made atomically. */
    OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.
                                            *   The association is made atomically. */
    OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.
                                            *   The association is made atomically. */
};
</pre></table></code></div></div><p>下面实现一个<code class="language-plaintext highlighter-rouge">UIView</code>的<code class="language-plaintext highlighter-rouge">Category</code>添加自定义属性<code class="language-plaintext highlighter-rouge">defaultColor</code>。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre>#import "ViewController.h"
#import "objc/runtime.h"

@interface UIView (DefaultColor)

@property (nonatomic, strong) UIColor *defaultColor;

@end

@implementation UIView (DefaultColor)

@dynamic defaultColor;

static char kDefaultColorKey;

- (void)setDefaultColor:(UIColor *)defaultColor {
    objc_setAssociatedObject(self, &amp;kDefaultColorKey, defaultColor, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (id)defaultColor {
    return objc_getAssociatedObject(self, &amp;kDefaultColorKey);
}

@end

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.

    UIView *test = [UIView new];
    test.defaultColor = [UIColor blackColor];
    NSLog(@"%@", test.defaultColor);
}

@end
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>打印结果： 2018-04-01 15:41:44.977732+0800 ocram[2053:63739] UIExtendedGrayColorSpace 0 1
</pre></table></code></div></div><p>打印结果来看，我们成功在分类上添加了一个属性，实现了它的<code class="language-plaintext highlighter-rouge">setter</code>和<code class="language-plaintext highlighter-rouge">getter</code>方法。 通过关联对象实现的属性的内存管理也是有ARC管理的，所以我们只需要给定适当的内存策略就行了，不需要操心对象的释放。</p><p>我们看看内存测量对于的属性修饰。</p><div class="table-wrapper"><table><thead><tr><th>内存策略<th>属性修饰<th>描述<tbody><tr><td>OBJC_ASSOCIATION_ASSIGN<td>@property (assign) 或 @property (unsafe_unretained)<td>指定一个关联对象的弱引用。<tr><td>OBJC_ASSOCIATION_RETAIN_NONATOMIC<td>@property (nonatomic, strong)<td>@property (nonatomic, strong) 指定一个关联对象的强引用，不能被原子化使用。<tr><td>OBJC_ASSOCIATION_COPY_NONATOMIC<td>@property (nonatomic, copy)<td>指定一个关联对象的copy引用，不能被原子化使用。<tr><td>OBJC_ASSOCIATION_RETAIN<td>@property (atomic, strong)<td>指定一个关联对象的强引用，能被原子化使用。<tr><td>OBJC_ASSOCIATION_COPY<td>@property (atomic, copy)<td>指定一个关联对象的copy引用，能被原子化使用。</table></div><h2 id="方法魔法method-swizzling方法添加替换和kvo实现">方法魔法(Method Swizzling)方法添加、替换和KVO实现</h2><h3 id="方法添加">方法添加</h3><p>实际上添加方法刚才在讲消息转发的时候，动态方法解析的时候就提到了。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>//class_addMethod(Class  _Nullable __unsafe_unretained cls, SEL  _Nonnull name, IMP  _Nonnull imp, const char * _Nullable types)
class_addMethod([self class], sel, (IMP)fooMethod, "v@:");
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">cls</code> 被添加方法的类<li><code class="language-plaintext highlighter-rouge">name</code> 添加的方法的名称的<code class="language-plaintext highlighter-rouge">SEL</code><li><code class="language-plaintext highlighter-rouge">imp</code> 方法的实现。该函数必须至少要有两个参数：<code class="language-plaintext highlighter-rouge">self</code>、<code class="language-plaintext highlighter-rouge">_cmd</code><li>类型编码</ul><h3 id="方法替换">方法替换</h3><p>下面实现一个替换<code class="language-plaintext highlighter-rouge">ViewController</code>的<code class="language-plaintext highlighter-rouge">viewDidLoad</code>方法的例子。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre>@implementation ViewController

+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        Class class = [self class];
        SEL originalSelector = @selector(viewDidLoad);
        SEL swizzledSelector = @selector(jkviewDidLoad);

        Method originalMethod = class_getInstanceMethod(class,originalSelector);
        Method swizzledMethod = class_getInstanceMethod(class,swizzledSelector);

        // judge the method named  swizzledMethod is already existed.
        BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));
        // if swizzledMethod is already existed.
        if (didAddMethod) {
            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
        }
        else {
            method_exchangeImplementations(originalMethod, swizzledMethod);
        }
    });
}

- (void)jkviewDidLoad {
    NSLog(@"替换的方法");

    [self jkviewDidLoad];
}

- (void)viewDidLoad {
    NSLog(@"自带的方法");

    [super viewDidLoad];
}

@end
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">swizzling</code> 应该只在 <code class="language-plaintext highlighter-rouge">+load</code> 中完成。在 <code class="language-plaintext highlighter-rouge">Objective-C</code> 的运行时中，每个类有两个方法都会自动调用。<code class="language-plaintext highlighter-rouge">+load</code> 是在一个类被初始装载时调用，<code class="language-plaintext highlighter-rouge">+initialize</code> 是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。</p><p><code class="language-plaintext highlighter-rouge">swizzling</code> 应该只在 <code class="language-plaintext highlighter-rouge">dispatch_once</code> 中完成，由于 <code class="language-plaintext highlighter-rouge">swizzling</code> 改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。<code class="language-plaintext highlighter-rouge">Grand Central Dispatch</code> 的 <code class="language-plaintext highlighter-rouge">dispatch_once</code> 满足了所需要的需求，并且应该被当做使用 <code class="language-plaintext highlighter-rouge">swizzling</code> 的初始化单例方法的标准。</p><p>实现图解如下图。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/Runtime%20-%20%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2.png" alt="" /></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>从图中可以看出，我们通过swizzling特性，将selectorC的方法实现IMPc与selectorN的方法实现IMPn交换了，当我们调用selectorC，也就是给对象发送selectorC消息时，所查找到的对应的方法实现就是IMPn而不是IMPc了。
</pre></table></code></div></div><h3 id="kvo实现">KVO实现</h3><p>全称是<code class="language-plaintext highlighter-rouge">Key-value observing</code>，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。在<code class="language-plaintext highlighter-rouge">MVC</code>大行其道的<code class="language-plaintext highlighter-rouge">Cocoa</code>中，<code class="language-plaintext highlighter-rouge">KVO</code>机制很适合实现<code class="language-plaintext highlighter-rouge">model</code>和<code class="language-plaintext highlighter-rouge">controller</code>类之间的通讯。</p><p><code class="language-plaintext highlighter-rouge">KVO</code>的实现依赖于 <code class="language-plaintext highlighter-rouge">Objective-C</code> 强大的 <code class="language-plaintext highlighter-rouge">Runtime</code>，当观察某对象 <code class="language-plaintext highlighter-rouge">A</code> 时，<code class="language-plaintext highlighter-rouge">KVO</code>机制动态创建一个对象<code class="language-plaintext highlighter-rouge">A</code>当前类的子类，并为这个新的子类重写了被观察属性 <code class="language-plaintext highlighter-rouge">keyPath</code> 的 <code class="language-plaintext highlighter-rouge">setter</code> 方法。<code class="language-plaintext highlighter-rouge">setter</code> 方法随后负责通知观察对象属性的改变状况。</p><p><code class="language-plaintext highlighter-rouge">Apple</code>使用了 <code class="language-plaintext highlighter-rouge">isa-swizzling</code> 来实现 <code class="language-plaintext highlighter-rouge">KVO</code> 。当观察对象<code class="language-plaintext highlighter-rouge">A</code>时，<code class="language-plaintext highlighter-rouge">KVO</code>机制动态创建一个新的名为：<code class="language-plaintext highlighter-rouge">NSKVONotifying_A</code>的新类，该类继承自对象<code class="language-plaintext highlighter-rouge">A</code>的本类，且 <code class="language-plaintext highlighter-rouge">KVO</code> 为 <code class="language-plaintext highlighter-rouge">NSKVONotifying_A</code> 重写观察属性的 <code class="language-plaintext highlighter-rouge">setter</code> 方法，<code class="language-plaintext highlighter-rouge">setter</code> 方法会负责在调用原 <code class="language-plaintext highlighter-rouge">setter</code> 方法之前和之后，通知所有观察对象属性值的更改情况。</p><ul><li><code class="language-plaintext highlighter-rouge">NSKVONotifying_A</code> 类剖析</ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>NSLog(@"self-&gt;isa:%@",self-&gt;isa);  
NSLog(@"self class:%@",[self class]);  
</pre></table></code></div></div><p>在建立<code class="language-plaintext highlighter-rouge">KVO</code>监听前，打印结果为：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>self-&gt;isa:A
self class:A
</pre></table></code></div></div><p>在这个过程，被观察对象的 <code class="language-plaintext highlighter-rouge">isa</code> 指针从指向原来的 <code class="language-plaintext highlighter-rouge">A</code> 类，被 <code class="language-plaintext highlighter-rouge">KVO</code> 机制修改为指向系统新创建的子类 <code class="language-plaintext highlighter-rouge">NSKVONotifying_A</code> 类，来实现当前类属性值改变的监听； 所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对 <code class="language-plaintext highlighter-rouge">KVO</code> 的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为 “<code class="language-plaintext highlighter-rouge">NSKVONotifying_A</code>” 的类，就会发现系统运行到注册 <code class="language-plaintext highlighter-rouge">KVO</code> 的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为 <code class="language-plaintext highlighter-rouge">NSKVONotifying_A</code> 的中间类，并指向这个中间类了。</p><ul><li>子类<code class="language-plaintext highlighter-rouge">setter</code>方法剖析</ul><p><code class="language-plaintext highlighter-rouge">KVO</code> 的键值观察通知依赖于 <code class="language-plaintext highlighter-rouge">NSObject</code> 的两个方法: <code class="language-plaintext highlighter-rouge">willChangeValueForKey:</code> 和 <code class="language-plaintext highlighter-rouge">didChangeValueForKey:</code>，在存取数值的前后分别调用这 2 个方法： 被观察属性发生改变之前，<code class="language-plaintext highlighter-rouge">willChangeValueForKey:</code> 被调用，通知系统该 <code class="language-plaintext highlighter-rouge">keyPath</code> 的属性值即将变更； 当改变发生后，<code class="language-plaintext highlighter-rouge">didChangeValueForKey:</code> 被调用，通知系统该 <code class="language-plaintext highlighter-rouge">keyPath</code> 的属性值已经变更；之后，<code class="language-plaintext highlighter-rouge">observeValueForKey:ofObject:change:context:</code> 也会被调用。且重写观察属性的 <code class="language-plaintext highlighter-rouge">setter</code> 方法这种继承方式的注入是在运行时而不是编译时实现的。</p><p><code class="language-plaintext highlighter-rouge">KVO</code> 为子类的观察者属性重写调用存取方法的工作原理在代码中相当于：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>- (void)setName:(NSString *)newName {
      [self willChangeValueForKey:@"name"];    //KVO 在调用存取方法之前总调用
      [super setValue:newName forKey:@"name"]; //调用父类的存取方法
      [self didChangeValueForKey:@"name"];     //KVO 在调用存取方法之后总调用
}
</pre></table></code></div></div><h2 id="消息转发热更新解决bugjspatch">消息转发(热更新)解决Bug(JSPatch)</h2><p><a href="https://github.com/bang590/JSPatch/wiki/JSPatch-实现原理详解">JSPatch</a> 是一个 <code class="language-plaintext highlighter-rouge">iOS</code> 动态更新框架，只需在项目中引入极小的引擎，就可以使用 <code class="language-plaintext highlighter-rouge">JavaScript</code> 调用任何 <code class="language-plaintext highlighter-rouge">Objective-C</code> 原生接口，获得脚本语言的优势：为项目动态添加模块，或替换项目原生代码动态修复 bug。</p><p>关于消息转发，前面已经讲到过了，消息转发分为三级，我们可以在每级实现替换功能，实现消息转发，从而不会造成崩溃。<code class="language-plaintext highlighter-rouge">JSPatch</code>不仅能够实现消息转发，还可以实现方法添加、替换能一系列功能。</p><h2 id="实现nscoding的自动归档和自动解档">实现NSCoding的自动归档和自动解档</h2><p>原理描述：用<code class="language-plaintext highlighter-rouge">runtime</code>提供的函数遍历<code class="language-plaintext highlighter-rouge">Model</code>自身所有属性，并对属性进行<code class="language-plaintext highlighter-rouge">encode</code>和<code class="language-plaintext highlighter-rouge">decode</code>操作。 核心方法：在<code class="language-plaintext highlighter-rouge">Model</code>的基类中重写方法：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre>- (id)initWithCoder:(NSCoder *)aDecoder {
    if (self = [super init]) {
        unsigned int outCount;
        Ivar * ivars = class_copyIvarList([self class], &amp;outCount);
        for (int i = 0; i &lt; outCount; i ++) {
            Ivar ivar = ivars[i];
            NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];
            [self setValue:[aDecoder decodeObjectForKey:key] forKey:key];
        }
    }
    return self;
}

- (void)encodeWithCoder:(NSCoder *)aCoder {
    unsigned int outCount;
    Ivar * ivars = class_copyIvarList([self class], &amp;outCount);
    for (int i = 0; i &lt; outCount; i ++) {
        Ivar ivar = ivars[i];
        NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];
        [aCoder encodeObject:[self valueForKey:key] forKey:key];
    }
}
</pre></table></code></div></div><h2 id="实现字典和模型的自动转换mjextension">实现字典和模型的自动转换(MJExtension)</h2><p>原理描述：用<code class="language-plaintext highlighter-rouge">runtime</code>提供的函数遍历<code class="language-plaintext highlighter-rouge">Model</code>自身所有属性，如果属性在<code class="language-plaintext highlighter-rouge">json</code>中有对应的值，则将其赋值。 核心方法：在<code class="language-plaintext highlighter-rouge">NSObject</code>的分类中添加方法</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre>- (instancetype)initWithDict:(NSDictionary *)dict {

    if (self = [self init]) {
        //(1)获取类的属性及属性对应的类型
        NSMutableArray * keys = [NSMutableArray array];
        NSMutableArray * attributes = [NSMutableArray array];
        /*
         * 例子
         * name = value3 attribute = T@"NSString",C,N,V_value3
         * name = value4 attribute = T^i,N,V_value4
         */
        unsigned int outCount;
        objc_property_t * properties = class_copyPropertyList([self class], &amp;outCount);
        for (int i = 0; i &lt; outCount; i ++) {
            objc_property_t property = properties[i];
            //通过property_getName函数获得属性的名字
            NSString * propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding];
            [keys addObject:propertyName];
            //通过property_getAttributes函数可以获得属性的名字和@encode编码
            NSString * propertyAttribute = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding];
            [attributes addObject:propertyAttribute];
        }
        //立即释放properties指向的内存
        free(properties);

        //(2)根据类型给属性赋值
        for (NSString * key in keys) {
            if ([dict valueForKey:key] == nil) continue;
            [self setValue:[dict valueForKey:key] forKey:key];
        }
    }
    return self;

}
</pre></table></code></div></div><p>以上就是<code class="language-plaintext highlighter-rouge">Runtime</code>应用的一些场景，本文到此结束了。</p><h1 id="参考文章">参考文章</h1><p><a href="https://blog.devtang.com/2013/10/15/objective-c-object-model/">Objective-C 对象模型及应用 - 唐巧</a></p><p><a href="https://blog.ibireme.com/2013/11/25/objc-object/">Objective-C 中的类和对象 - ibireme</a></p><p><a href="https://kangzubin.com/objc-runtime-articles/">Objective-C Runtime 大佬系列文章整理</a></p><p><a href="https://www.jianshu.com/p/d6a68575ce10">Runtime 简介 - wuhao </a></p><p><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/">Objective-C Runtime - 杨萧玉</a></p><p><a href="http://chuquan.me/2018/10/20/ios-runtime-message-sending-and-forwarding/">Objective-C Runtime 消息传递与转发 - 楚权</a></p><p><a href="http://qiuxuewei.com/post/ios-runtime-xiang-jie/">iOS - Runtime 详解 - 极客学伟</a></p><p><a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime?language=objc">Objective-C Runtime</a></p><p><a href="https://www.cnblogs.com/dins/p/ios-runtime.html">iOS Runtime</a></p><p><a href="https://halfrost.com/objc_runtime_isa_class/">神经病院 Objective-C Runtime 入院第一天—— isa 和 Class</a></p><p><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runtime.html">Objective-C Runtime - 面试题</a></p><p><a href="https://juejin.cn/post/6844903586216804359#heading-23">iOS Runtime详解 - jackyshan</a></p><p><a href="http://www.lymanli.com/2018/03/15/新手也看得懂的-iOS-Runtime-教程/">新手也看得懂的 iOS Runtime 教程 - Lyman</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/ios/'>iOS</a>, <a href='/categories/runtime/'>Runtime</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/objective-c/" class="post-tag no-text-decoration" >Objective-C</a> <a href="/tags/runtime/" class="post-tag no-text-decoration" >Runtime</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Objective-C - Runtime 总结梳理 - Ouyang Rong&url=https://ouyangrong.com/posts/iOS-Runtime-Summary/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Objective-C - Runtime 总结梳理 - Ouyang Rong&u=https://ouyangrong.com/posts/iOS-Runtime-Summary/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Objective-C - Runtime 总结梳理 - Ouyang Rong&url=https://ouyangrong.com/posts/iOS-Runtime-Summary/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/AnnualSummary-2023/">2023 年度总结</a><li><a href="/posts/AnnualSummary-2022/">2022 年度总结</a><li><a href="/posts/Source-Analysis-SDWebImage/">iOS SDWebImage 源码分析</a><li><a href="/posts/Source-Analysis-AFNetworking/">AFNetworking 源码分析</a><li><a href="/posts/architecture-design/">iOS 架构设计</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/gcd/">GCD</a> <a class="post-tag" href="/tags/objective-c/">Objective-C</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a> <a class="post-tag" href="/tags/afnetworking/">AFNetworking</a> <a class="post-tag" href="/tags/%E5%A4%A7%E5%8F%B7/">大号</a> <a class="post-tag" href="/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">年度总结</a> <a class="post-tag" href="/tags/%E6%80%BB%E7%BB%93/">总结</a> <a class="post-tag" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a> <a class="post-tag" href="/tags/arc/">ARC</a> <a class="post-tag" href="/tags/fmdb/">FMDB</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/iOS-Runloop-Summary/"><div class="card-body"> <span class="timeago small" > Nov 10, 2021 <i class="unloaded">2021-11-10T18:11:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Runloop 总结梳理</h3><div class="text-muted small"><p> RunLoop概念 RunLoop介绍 RunLoop 是什么？RunLoop 顾名思义就是一种循环，只不过它这种循环比较高级。一般的 while 循环会导致 CPU 进入忙等待状态，而 RunLoop 则是一种“闲”等待，这部分可以类比 Linux 下的 epoll。当没有事件时，RunLoop 会进入休眠状态；当有事件发生时，RunLoop 会去找对应的 Handler 处理事件...</p></div></div></a></div><div class="card"> <a href="/posts/iOS-Data-Storage/"><div class="card-body"> <span class="timeago small" > Nov 26, 2021 <i class="unloaded">2021-11-26T18:11:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>iOS 本地数据存储</h3><div class="text-muted small"><p> 沙盒 iOS本地化存储的数据保存在沙盒中， 并且每个应用的沙盒是相对独立的。每个应用的沙盒文件结构都是相同的，如下图所示： Documents：iTunes会备份该目录。一般用来存储需要持久化的数据。 Library/Caches：缓存，iTunes不会备份该目录。内存不足时会被清除，应用没有运行时，可能会被清除。一般存储体积大、不需要备份的非重要数据。 Library...</p></div></div></a></div><div class="card"> <a href="/posts/iOS-YYKit-CodeLearn/"><div class="card-body"> <span class="timeago small" > Jan 7, 2022 <i class="unloaded">2022-01-07T18:11:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>iOS YYKit 源码学习</h3><div class="text-muted small"><p> YYKit 框架的作者是现任职于滴滴的郭曜源（ibireme）。 最近一系列开源项目 YYKit 在 iOS 社区引起广泛反响，由于其代码质量高，在短时间内就收获了大量的 star，它的作者是国人开发者 ibireme，优酷土豆的 iOS 开发工程师郭曜源，InfoQ 社区编辑唐巧对他进行了采访，了解这些开源项目背后的故事。 大家好，我叫郭曜源，是一个 iOS 开发者，现居北京，...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/iOS-Memory-Management/" class="btn btn-outline-primary" prompt="Older"><p>深入理解 iOS 内存管理（Memory Management）</p></a> <a href="/posts/iOS-Runloop-Summary/" class="btn btn-outline-primary" prompt="Newer"><p>Runloop 总结梳理</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//ouyangrong-1.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Objective-C - Runtime 总结梳理'; this.page.url = 'https://ouyangrong.com/posts/iOS-Runtime-Summary/'; this.page.identifier = '/posts/iOS-Runtime-Summary/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/ouyangrong1313">Ouyang Rong</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/gcd/">GCD</a> <a class="post-tag" href="/tags/objective-c/">Objective C</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a> <a class="post-tag" href="/tags/afnetworking/">AFNetworking</a> <a class="post-tag" href="/tags/%E5%A4%A7%E5%8F%B7/">大号</a> <a class="post-tag" href="/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">年度总结</a> <a class="post-tag" href="/tags/%E6%80%BB%E7%BB%93/">总结</a> <a class="post-tag" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a> <a class="post-tag" href="/tags/arc/">ARC</a> <a class="post-tag" href="/tags/fmdb/">FMDB</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://ouyangrong.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
