<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="iOS 本地数据存储" /><meta name="author" content="Ouyang Rong" /><meta property="og:locale" content="en_US" /><meta name="description" content="沙盒" /><meta property="og:description" content="沙盒" /><link rel="canonical" href="https://ouyangrong.com/posts/iOS-Data-Storage/" /><meta property="og:url" content="https://ouyangrong.com/posts/iOS-Data-Storage/" /><meta property="og:site_name" content="Ouyang Rong" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-11-26T18:11:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="iOS 本地数据存储" /><meta name="twitter:site" content="@ouyangrong1313" /><meta name="twitter:creator" content="@Ouyang Rong" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Ouyang Rong"},"dateModified":"2021-11-29T11:45:32+08:00","datePublished":"2021-11-26T18:11:00+08:00","description":"沙盒","headline":"iOS 本地数据存储","mainEntityOfPage":{"@type":"WebPage","@id":"https://ouyangrong.com/posts/iOS-Data-Storage/"},"url":"https://ouyangrong.com/posts/iOS-Data-Storage/"}</script><title>iOS 本地数据存储 | Ouyang Rong</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Ouyang Rong"><meta name="application-name" content="Ouyang Rong"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-4EXCTKYR2M"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-4EXCTKYR2M'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/images/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Ouyang Rong</a></div><div class="site-subtitle font-italic">Stay Hungry, Stay Foolish.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/ouyangrong1313" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/ouyangrong1313" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['951607559','qq.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>iOS 本地数据存储</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>iOS 本地数据存储</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Ouyang Rong </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Nov 26, 2021, 6:11 PM +0800" prep="on" > Nov 26, 2021 <i class="unloaded">2021-11-26T18:11:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Nov 29, 2021, 11:45 AM +0800" prefix="Updated " > Nov 29, 2021 <i class="unloaded">2021-11-29T11:45:32+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6939 words">38 min</span></div></div><div class="post-content"><h1 id="沙盒">沙盒</h1><p>iOS本地化存储的数据保存在沙盒中， 并且每个应用的沙盒是相对独立的。每个应用的沙盒文件结构都是相同的，如下图所示：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8-%E6%B2%99%E7%9B%92.png" alt="" /></p><ul><li>Documents：iTunes会备份该目录。一般用来存储需要持久化的数据。<li>Library/Caches：缓存，iTunes不会备份该目录。内存不足时会被清除，应用没有运行时，可能会被清除。一般存储体积大、不需要备份的非重要数据。<li>Library/Preference：iTunes会备份该目录，可以用来存储一些偏好设置。<li>tmp：iTunes不会备份这个目录，用来保存临时数据，应用退出时会清除该目录下的数据。</ul><p>如何拿到每个文件夹的路径呢？</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>// 这个方法返回的是一个数组，并且这个数组只有一个元素，所以我们可以用lastObject或lastObject来拿到Documents目录的路径
NSString *documentPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;
// 得到Document目录下的test.plist文件的路径
NSString *filePath = [documentPath stringByAppendingPathComponent:@"test.plist"];
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>// 获取temp路径
NSString *tmp= NSTemporaryDirectory();
// 获取temp下test.data文件的路径
NSString *filePath = [tmp stringByAppendingPathComponent:@"test.data"];
</pre></table></code></div></div><p>所以，如果程序中有需要长时间持久化的数据，就选择Documents，如果有体积大但是并不重要的数据，就可以选择交给Library，而临时没用的数据当然是放到temp。至于Preference则可以用来保存一些设置类信息，后面会讲到偏好设置的使用方法。</p><h1 id="plist">Plist</h1><p>Plist文件的Type可以是字典NSDictionary或数组NSArray，也就是说可以把字典或数组直接写入到文件中。 NSString、NSData、NSNumber等类型，也可以使用<code class="language-plaintext highlighter-rouge">writeToFile:atomically:</code>方法直接将对象写入文件中，只是Type为空。</p><p>下面就举个例子来看一下如何使用Plist来存储数据。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>// 准备要保存的数据
NSDictionary *dict = [NSDictionary dictionaryWithObject:@"first" forKey:@"1"];

// 获取路径
NSString *documentPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;
NSString *filePath = [documentPath stringByAppendingPathComponent:@"test.plist"];

// 写入数据
[dict writeToFile:filePath atomically:YES];
</pre></table></code></div></div><p>上面的代码运行之后，在应用沙盒的Documents中就创建了一个plist文件，并且已经写入数据保存。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8-%E7%94%9F%E6%88%90%E7%9A%84plist%E6%96%87%E4%BB%B6.png" alt="" /></p><p>数据存储了，那么如何读取呢？</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>// 获取plist文件路径
NSString *documentPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;
NSString *filePath = [documentPath stringByAppendingPathComponent:@"test.plist"];

//解析数据，log出的结果为first，读取成功
NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:filePath];
NSString *result = dict[@"1"];
NSLog(@"%@",result);
</pre></table></code></div></div><p>上面这段代码就读出了plist种的数据。</p><h1 id="preference偏好设置">Preference偏好设置</h1><p>偏好设置的使用非常方便快捷，我们一般使用它来进行一些设置的记录，比如用户名，开关是否打开等设置。Preference是通过NSUserDefaults来使用的，是通过键值对的方式记录设置。下面举个例子。</p><p>利用NSUserDefaults判断APP是不是首次启动。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>// 启动的时候判断key有没有value，如果有，说明已经启动过了，如果没有，说明是第一次启动
if (![[NSUserDefaults standardUserDefaults] valueForKey:@"first"]) {
    //如果是第一次启动，就运用偏好设置给key设置一个value
    [[NSUserDefaults standardUserDefaults] setValue:@"start" forKey:@"first"];
    NSLog(@"是第一次启动");
} else {
    NSLog(@"不是第一次启动");
}
</pre></table></code></div></div><p>过键值对的方式非常easy的保存了数据。</p><blockquote><p>注意：NSUserDefaults可以存储的数据类型包括：NSData、NSString、NSNumber、NSDate、NSArray、NSDictionary。如果要存储其他类型，则需要转换为前面的类型，才能用NSUserDefaults存储。</p></blockquote><p>下面的例子是用NSUserDefaults存储图片，需要先把图片转换成NSData类型。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>UIImage *image=[UIImage imageNamed:@"photo"];
// UIImage对象转换成NSData
NSData *imageData = UIImageJPEGRepresentation(image, 100);
// 偏好设置可以保存NSData，但是不能保存UIimage
[[NSUserDefaults standardUserDefaults] setObject:imageData forKey:@"image"];
// 读出data
NSData *getImageData = [[NSUserDefaults standardUserDefaults] dataForKey:@"image"];
// NSData转换为UIImage
UIImage *Image = [UIImage imageWithData:imageData];
</pre></table></code></div></div><h1 id="nskeyedarchiver归档nskeyedunarchiver解档">NSKeyedArchiver归档/NSKeyedUnarchiver解档</h1><p>归档和解档会在写入、读出数据之前进行序列化、反序列化，数据的安全性相对高一些。</p><h2 id="对单个简单对象进行归档解档">对单个简单对象进行归档/解档</h2><p>与plist差不多，对于简单的数据进行归档，直接写入文件路径。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>// 获取归档文件路径
NSString *documentPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;
NSString *filePath = [documentPath stringByAppendingPathComponent:@"test"];

// 对字符串@”test”进行归档，写入到filePath中
[NSKeyedArchiver archiveRootObject:@"test" toFile:filePath];

// 根据保存数据的路径filePath解档数据
NSString *result = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath];
// log结构为@”test”，就是上面归档的数据
NSLog(@"%@",result);
</pre></table></code></div></div><p>当然，也可以存储NSArray，NSDictionary等对象。</p><h2 id="对多个对象进行归档解档">对多个对象进行归档/解档</h2><p>这种情况可以一次保存多种不同类型的数据，最终使用的是与plist相同的<code class="language-plaintext highlighter-rouge">writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile</code>来写入数据。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre>    // 获取归档路径
    NSString *documentPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;
    NSString *filePath = [documentPath stringByAppendingPathComponent:@"test"];

    // 用来承载数据的NSMutableData
    NSMutableData *data = [[NSMutableData alloc] init];
    // 归档对象
    NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];
    // 将要被保存的三个数据
    NSString *name = @"jack";
    int age = 17;
    double height = 1.78;
    // 运用encodeObject:方法归档数据
    [archiver encodeObject:name forKey:@"name"];
    [archiver encodeInt:age forKey:@"age"];
    [archiver encodeDouble:height forKey:@"height"];
    // 结束归档
    [archiver finishEncoding];
    // 写入数据（存储数据）
    [data writeToFile:filePath atomically:YES];

    // NSMutableData用来承载解档出来的数据
    NSMutableData *resultData = [[NSMutableData alloc] initWithContentsOfFile:filePath];
    // 解档对象
    NSKeyedUnarchiver *unArchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:resultData];
    // 分别解档出三个数据
    NSString *resultName = [unArchiver decodeObjectForKey:@"name"];
    int resultAge = [unArchiver decodeIntForKey:@"age"];
    double resultHeight = [unArchiver decodeDoubleForKey:@"height"];
    // 结束解档
    [unArchiver finishDecoding];
    // 成功打印出结果，说明成功归档解档
    NSLog(@"name = %@, age = %d, height = %.2f",resultName,resultAge,resultHeight);
</pre></table></code></div></div><h2 id="归档保存自定义对象">归档保存自定义对象</h2><p>定义一个Person类，如果想对person进行归档解档，首先要让Person遵守协议。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre>//Person.h

#import &lt;Foundation/Foundation.h&gt;

// 遵守NSCoding协议
@interface Person : NSObject&lt;NSCoding&gt;

@property (nonatomic, copy) NSString *name;
@property (nonatomic, assign) NSInteger age;
// 自定义的归档保存数据的方法
+(void)savePerson:(Person *)person;
// 自定义的读取沙盒中解档出的数据
+(Person *)getPerson;

@end
</pre></table></code></div></div><p>NSCoding协议有2个方法：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>// 归档时调用这个方法，在方法中使用encodeObject:forKey:归档变量。
- (void)encodeWithCoder:(NSCoder *)aCoder
// 解档时调用这个方法，在方法中使用decodeObject:forKey解档变量。
- (instancetype)initWithCoder:(NSCoder *)aDecoder
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre>//Person.m

#import "Person.h"

@implementation Person

// 归档（Key建议使用宏代替）
- (void)encodeWithCoder:(NSCoder *)aCoder {
    [aCoder encodeObject:self.name forKey:@"name"];
    [aCoder encodeInteger:self.age forKey:@"age"];
}

// 解档
-(instancetype)initWithCoder:(NSCoder *)aDecoder {
    if (self=[super init]) {
        self.name = [aDecoder decodeObjectForKey:@"name"];
        self.age = [aDecoder decodeIntegerForKey:@"age"];
    }
    return self;
}

// 类方法，运用NSKeyedArchiver归档数据
+(void)savePerson:(Person *)person {
    NSString *docPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;
    NSString *path=[docPath stringByAppendingPathComponent:@"Person.plist"];
    [NSKeyedArchiver archiveRootObject:person toFile:path];
}

// 类方法，使用NSKeyedUnarchiver解档数据
+(Person *)getPerson {
    NSString *docPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;
    NSString *path=[docPath stringByAppendingPathComponent:@"Person.plist"];
    Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:path];
    return person;
}

@end
</pre></table></code></div></div><p>使用runtime动态获取类属性减少冗余代码：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre>#import &lt;objc/runtime.h&gt;

- (NSArray *)perperiesWithClass:(Class)cls
{
    NSMutableArray *perperies = [NSMutableArray array];
    unsigned int outCount;
    // 动态获取属性
    objc_property_t *properties = class_copyPropertyList(cls, &amp;outCount);
    // 遍历person类的所有属性
    for (int i = 0; i &lt; outCount; i++)
    {
        objc_property_t property = properties[i];
        const char *name = property_getName(property);
        NSString *s = [[NSString alloc] initWithUTF8String:name];
        [perperies addObject:s];
    }
    return perperies;
}

// 归档会触发
- (void)encodeWithCoder:(NSCoder *)aCoder
{
    for (NSString *perperty in [self perperiesWithClass:[self class]])
    {
        [aCoder encodeObject:perperty forKey:perperty];
    }
}

// 解归档会触发
- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder
{
    if (self = [super init])
    {
        for (NSString *perperty in [self perperiesWithClass:[self class]])
        {
            [self setValue:[aDecoder decodeObjectForKey:perperty] forKey:perperty];;
        }
    }
    return self;
}
</pre></table></code></div></div><p>下面就可以在需要的地方归档或解档Person对象。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>    // 创建Person对象
    Person *person = [Person new];
    person.name = @"jack";
    person.age = 17;
    // 归档保存数据
    [Person savePerson:person];
    // 解档拿到数据
    Person *resultPerson = [Person getPerson];
    // 打印出结果，证明归档解档成功
    NSLog(@"name = %@, age = %ld",resultPerson.name,resultPerson.age);
</pre></table></code></div></div><h1 id="sqlite3的使用">SQLite3的使用</h1><ol><li>首先需要添加库文件libsqlite3.0.tbd<li>导入头文件#import<li>打开数据库<li>创建表<li>对数据表进行增删改查操作<li>关闭数据库</ol><p>上代码之前，有些问题你需要了解:</p><ul><li>SQLite3不区分大小写，但也有需要注意的地方，例如GLOB 和 glob 具有不同作用<li>SQLite3有5种基本数据类型 text、integer、float、boolean、blob<li>SQLite3是无类型的，在创建的时候你可以不声明字段的类型，不过还是建议加上数据类型</ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>create table t_student(name, age);
create table t_student(name text, age integer);
</pre></table></code></div></div><p>下面的代码就是SQLite3的基本使用方法，带有详细注释。代码中用到了一个Student类，这个类有两个属性name和age。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
</pre><td class="rouge-code"><pre>// sqliteTest.m

#import "sqliteTest.h"
// 1.首先导入头文件
#import &lt;sqlite3.h&gt;

// 2.数据库
static sqlite3 *db;

@implementation sqliteTest

// 3.打开数据库
+ (void)openSqlite {
    // 数据库已经打开
    if (db != nil) {
        NSLog(@"数据库已经打开");
        return;
    }
    // 创建数据文件路径
    NSString *string = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
    NSString *path = [string stringByAppendingPathComponent:@"Student.sqlite"];
    NSLog(@"%@",path);
    // 打开数据库
    int result = sqlite3_open(path.UTF8String, &amp;db);
    if (result == SQLITE_OK) {
        NSLog(@"数据库打开成功");
    } else {
        NSLog(@"数据库打开失败");
    }
}

// 4.创建表
+ (void)createTable {
    // 创建表的SQLite语句，其中id是主键，not null 表示在表中创建纪录时这些字段不能为NULL
    NSString *sqlite = [NSString stringWithFormat:@"create table if not exists t_student (id integer primary key autoincrement, name text not null, age integer)"];
    // 用来记录错误信息
    char *error = NULL;
    // 执行SQLite语句
    int result = sqlite3_exec(db, sqlite.UTF8String, nil, nil, &amp;error);
    if (result == SQLITE_OK) {
        NSLog(@"创建表成功");
    }else {
        NSLog(@"创建表失败");
    }
}

// 5.添加数据
+ (void)addStudent:(Student *)stu {
    // 增添数据的SQLite语句
    NSString *sqlite = [NSString stringWithFormat:@"insert into t_student (name,age) values ('%@','%ld')",stu.name,stu.age];
    char *error = NULL;
    int result = sqlite3_exec(db, [sqlite UTF8String], nil, nil, &amp;error);
    if (result == SQLITE_OK) {
        NSLog(@"添加数据成功");
    } else {
        NSLog(@"添加数据失败");
    }
}

// 6.删除数据
+ (void)deleteStuWithName:(NSString *)name {
    // 删除特定数据的SQLite语句
    NSString *sqlite = [NSString stringWithFormat:@"delete from t_student where name = '%@'",name];
    char *error = NULL;
    int result = sqlite3_exec(db, sqlite.UTF8String, nil, nil, &amp;error);
    if (result == SQLITE_OK) {
        NSLog(@"删除数据成功");
    } else {
        NSLog(@"删除数据失败");
    }
}

// 7.更改数据
+ (void)upDateWithStudent:(Student *)stu WhereName:(NSString *)name {
    // 更新特定字段的SQLite语句
    NSString *sqlite = [NSString stringWithFormat:@"update t_student set name = '%@', age = '%ld' where name = '%@'",stu.name,stu.age,name];
    char *error = NULL;
    int result = sqlite3_exec(db, sqlite.UTF8String, nil, nil, &amp;error);
    if (result == SQLITE_OK) {
        NSLog(@"修改数据成功");
    } else {
        NSLog(@"修改数据失败");
    }
}

// 8.根据条件查询
+ (NSMutableArray *)selectWithAge:(NSInteger)age {
    // 可变数组，用来保存查询到的数据
    NSMutableArray *array = [NSMutableArray array];
    // 查询所有数据的SQLite语句
    NSString *sqlite = [NSString stringWithFormat:@"select * from t_student where age = '%ld'",age];
    // 定义一个stmt存放结果集
    sqlite3_stmt *stmt = NULL;
    // 执行
    int result = sqlite3_prepare(db, sqlite.UTF8String, -1, &amp;stmt, NULL);
    if (result == SQLITE_OK) {
        NSLog(@"查询成功");
        // 遍历查询到的所有数据，并添加到上面的数组中
        while (sqlite3_step(stmt) == SQLITE_ROW) {
            Student *stu = [[Student alloc] init];
            // 获得第1列的姓名，第0列是id
            stu.name = [NSString stringWithUTF8String:(const char *)sqlite3_column_text(stmt, 1)];
            // 获得第2列的年龄
            stu.age = sqlite3_column_int(stmt, 2);
            [array addObject:stu];
        }
    } else {
        NSLog(@"查询失败");
    }
    // 销毁stmt，防止内存泄漏
    sqlite3_finalize(stmt);
    return array;
}

// 9.查询所有数据
+ (NSMutableArray *)selectStudent {
    // 可变数组，用来保存查询到的数据
    NSMutableArray *array = [NSMutableArray array];
    // 查询所有数据的SQLite语句
    NSString *sqlite = [NSString stringWithFormat:@"select * from t_student"];
    // 定义一个stmt存放结果集
    sqlite3_stmt *stmt = NULL;
    // 执行
    int result = sqlite3_prepare(db, sqlite.UTF8String, -1, &amp;stmt, NULL);
    if (result == SQLITE_OK) {
        NSLog(@"查询成功");
        // 遍历查询到的所有数据，并添加到上面的数组中
        while (sqlite3_step(stmt) == SQLITE_ROW) {
            Student *stu = [[Student alloc] init];
            // 获得第1列的姓名，第0列是id
            stu.name = [NSString stringWithUTF8String:(const char *)sqlite3_column_text(stmt, 1)];
            // 获得第2列的年龄
            stu.age = sqlite3_column_int(stmt, 2);
            [array addObject:stu];
        }
    } else {
        NSLog(@"查询失败");
    }
    // 销毁stmt，防止内存泄漏
    sqlite3_finalize(stmt);
    return array;
}

// 10.删除表中的所有数据
+ (void)deleteAllData {
    NSString *sqlite = [NSString stringWithFormat:@"delete from t_student"];
    char *error = NULL;
    int result = sqlite3_exec(db, sqlite.UTF8String, nil, nil, &amp;error);
    if (result == SQLITE_OK) {
        NSLog(@"清除数据库成功");
    } else {
        NSLog(@"清除数据库失败");
    }
}

// 11.删除表
+ (void)dropTable {
    NSString *sqlite = [NSString stringWithFormat:@"drop table if exists t_student"];
    char *error = NULL;
    int result = sqlite3_exec(db, sqlite.UTF8String, nil, nil, &amp;error);
    if (result == SQLITE_OK) {
        NSLog(@"删除表成功");
    } else {
        NSLog(@"删除表失败");
    }
}

// 12.关闭数据库
+ (void)closeSqlite {
    int result = sqlite3_close(db);
    if (result == SQLITE_OK) {
        NSLog(@"数据库关闭成功");
    } else {
        NSLog(@"数据库关闭失败");
    }
}
</pre></table></code></div></div><p><strong>附上SQLite的基本语句</strong></p><ul><li>创建表: create table if not exists 表名 (字段名1, 字段名2)</ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>create table if not exists t_student (id integer primary key autoincrement, name text not null, age integer)
</pre></table></code></div></div><ul><li>增加数据: insert into 表名 (字段名1, 字段名2) values（字段1的值, 字段2的值）</ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>insert into t_student (name,age) values (@"Jack",@17);
</pre></table></code></div></div><ul><li>根据条件删除数据：delete from 表名 where 条件</ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>delete from t_student where name = @"Jack";
</pre></table></code></div></div><ul><li>删除表中所有的数据：delete from 表名</ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>delete from t_student
</pre></table></code></div></div><ul><li>根据条件更改某个数据：update 表名 set 字段1 = ‘值1’, 字段2 = ‘值2’ where 字段1 = ‘字段1的当前值’</ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>update t_student set name = 'lily', age = '16' where name = 'Jack'
</pre></table></code></div></div><ul><li>根据条件查找：select * from 表名 where 字段1 = ‘字段1的值’</ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>select * from t_student where age = '16'
</pre></table></code></div></div><ul><li>查找所有数据：select * from 表名</ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>select * from t_student
</pre></table></code></div></div><ul><li>删除表：drop table 表名</ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>drop table t_student
</pre></table></code></div></div><ul><li>排序查找：select * from 表名 order by 字段</ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>select * from t_student order by age asc（升序，默认）
select * from t_student order by age desc（降序）
</pre></table></code></div></div><ul><li>限制：select * from 表名 limit 值1, 值2</ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>select * from t_student limit 5, 10（跳过5个，一共取10个数据）
</pre></table></code></div></div><h1 id="fmdb">FMDB</h1><p>FMDB封装了SQLite的C语言API，更加面向对象。 首先需要明确的是FMDB中的三个类。</p><ul><li>FMDatabase：可以理解成一个数据库。<li>FMResultSet：查询的结果集合。<li>FMDatabaseQueue：运用多线程，可执行多个查询、更新，线程安全。</ul><h2 id="fmdb基本语法">FMDB基本语法</h2><p>查询：<code class="language-plaintext highlighter-rouge">executeQuery:</code> SQLite语句命令。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>[db executeQuery:@"select id, name, age from t_person"]
</pre></table></code></div></div><p>其余的操作都是“更新”：<code class="language-plaintext highlighter-rouge">executeUpdate:</code> SQLite语句命令。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>// CREATE, UPDATE, INSERT, DELETE, DROP，都使用executeUpdte
[db executeUpdate:@"create table if not exists t_person (id integer primary key autoincrement, name text, age integer)"]
// @"insert into t_person (name) values(?)
// @"delete from t_person where age &lt; 50"
// @"update t_person set name = 'hello world' where age &gt; 50"
// @"select * from t_person"
</pre></table></code></div></div><h2 id="fmdb的基本使用">FMDB的基本使用</h2><p>在项目中导入FMDB框架和sqlite3.0.tbd，导入头文件。</p><h3 id="1-打开数据库并创建表">1. 打开数据库，并创建表</h3><ul><li>初始化FMDatabase：<code class="language-plaintext highlighter-rouge">FMDatabase *db = [FMDatabase databaseWithPath:filePath];</code> 其中的filePath是提前准备好要存放数据的路径。<li>打开数据库：<code class="language-plaintext highlighter-rouge">[db open];</code><li>创建数据表：<code class="language-plaintext highlighter-rouge">[db executeUpdate:@”create table if not exists t_person (id integer primary key autoincrement, name text, age integer)”];</code></ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre>#import "ViewController.h"
#import &lt;FMDB.h&gt;

@interface ViewController ()

@end

@implementation ViewController{
    FMDatabase *db;
}

- (void)openCreateDB {
    // 存放数据的路径
    NSString *path = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).firstObject;
    NSString *filePath = [path stringByAppendingPathComponent:@"person.sqlite"];

    //初始化FMDatabase
    db = [FMDatabase databaseWithPath:filePath];

    //打开数据库并创建person表，person中有主键id，姓名name，年龄age
    if ([db open]) {
        BOOL success = [db executeUpdate:@"create table if not exists t_person (id integer primary key autoincrement, name text, age integer)"];
        if (success) {
            NSLog(@"创表成功");
        }else {
            NSLog(@"创建表失败");
        }
    } else {
        NSLog(@"打开失败");
    }
}
</pre></table></code></div></div><h3 id="2-插入数据">2. 插入数据</h3><p>运用executeUpdate方法执行插入数据命令：<code class="language-plaintext highlighter-rouge">[db executeUpdate:@”insert into t_person(name,age) values(?,?)”,@”jack”,@17];</code></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>-(void)insertData {
    BOOL success = [db executeUpdate:@"insert into t_person(name,age) values(?,?)",@"jack",@17];
    if (success) {
        NSLog(@"添加数据成功");
    } else {
        NSLog(@"添加数据失败");
    }
}
</pre></table></code></div></div><h3 id="3-删除数据">3. 删除数据</h3><p>删除姓名为lily的数据：<code class="language-plaintext highlighter-rouge">[db executeUpdate:@"delete from t_person where name = ‘lily’"];</code></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>-(void)deleteData {
    BOOL success = [db executeUpdate:@"delete from t_person where name = 'lily'"];
    if (success) {
        NSLog(@"删除数据成功");
    } else {
        NSLog(@"删除数据失败");
    }
}
</pre></table></code></div></div><h3 id="4-修改数据">4. 修改数据</h3><p>把年龄为17岁的数据，姓名改为lily：<code class="language-plaintext highlighter-rouge">[db executeUpdate:@"update t_person set name = ‘lily’ where age = 17"];</code></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>-(void)updateData {
    BOOL success = [db executeUpdate:@"update t_person set name = 'lily' where age = 17"];
    if (success) {
        NSLog(@"更新数据成功");
    } else {
        NSLog(@"更新数据失败");
    }
}
</pre></table></code></div></div><h3 id="5-查询数据">5. 查询数据</h3><ul><li>执行查询语句，用FMResultSet接收查询结果：<code class="language-plaintext highlighter-rouge">FMResultSet *set = [db executeQuery:@"select id, name, age from t_person"];</code><li>遍历查询结果：<code class="language-plaintext highlighter-rouge">[set next];</code><li>拿到每条数的姓名：<code class="language-plaintext highlighter-rouge">NSString *name = [set stringForColumnIndex:1];</code>也可以这样拿到每条数据的姓名：<code class="language-plaintext highlighter-rouge">NSString *name = [result stringForColumn:@"name"];</code></ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre> FMResultSet *set = [db executeQuery:@"select id, name, age from t_person"];
    while ([set next]) {
        int ID = [set intForColumnIndex:0];
        NSString *name = [set stringForColumnIndex:1];
        int age = [set intForColumnIndex:2];
        NSLog(@"%d,%@,%d",ID,name,age);
    }
}
</pre></table></code></div></div><h3 id="6-删除表">6. 删除表</h3><p>删除指定表：<code class="language-plaintext highlighter-rouge">[db executeUpdate:@"drop table if exists t_person"];</code></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>-(void)dropTable {
    BOOL success = [db executeUpdate:@"drop table if exists t_person"];
    if (success) {
        NSLog(@"删除表成功");
    } else {
        NSLog(@"删除表失败");
    }
}
</pre></table></code></div></div><h2 id="fmdatabasequeue基本使用">FMDatabaseQueue基本使用</h2><p>FMDatabase是线程不安全的，当FMDB数据存储想要使用多线程的时候，FMDatabaseQueue就派上用场了。</p><p>初始化FMDatabaseQueue的方法与FMDatabase类似。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>// 文件路径
NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
NSString *filePath = [path stringByAppendingPathComponent:@"student.sqlite"];
// 初始化FMDatabaseQueue
FMDatabaseQueue *dbQueue = [FMDatabaseQueue databaseQueueWithPath:filePath];
</pre></table></code></div></div><p>在FMDatabaseQueue中执行命令的时候也是非常方便，直接在一个block中进行操作。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre>-(void)FMDdatabaseQueueFunction {
    NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
    // 文件路径
    NSString *filePath = [path stringByAppendingPathComponent:@"student.sqlite"];
    // 初始化FMDatabaseQueue
    FMDatabaseQueue *dbQueue = [FMDatabaseQueue databaseQueueWithPath:filePath];
    // 在block中执行SQLite语句命令
    [dbQueue inDatabase:^(FMDatabase * _Nonnull db) {
        // 创建表
        [db executeUpdate:@"create table if not exists t_student (id integer primary key autoincrement, name text, age integer)"];
        // 添加数据
        [db executeUpdate:@"insert into t_student(name,age) values(?,?)",@"jack",@17];
        [db executeUpdate:@"insert into t_student(name,age) values(?,?)",@"lily",@16];
        // 查询数据
        FMResultSet *set = [db executeQuery:@"select id, name, age from t_student"];
        //遍历查询到的数据
        while ([set next]) {
            int ID = [set intForColumn:@"id"];
            NSString *name = [set stringForColumn:@"name"];
            int age = [set intForColumn:@"age"];
            NSLog(@"%d,%@,%d",ID,name,age);
        }
    }];
}
</pre></table></code></div></div><h2 id="fmdb中的事务">FMDB中的事务</h2><p>什么是事务？</p><p>事务（Transaction）是不可分割的一个整体操作，要么都执行，要么都不执行。举个例子，幼儿园有20位小朋友由老师组织出去春游，返校的时候，所有人依次登上校车，这时候如果有一位小朋友没有上车，车也是不能出发的。所以哪怕19人都上了车，也等于0人上车。20人是一个整体。</p><p>FMDB中有事务的回滚操作，也就是说，当一个整体事务在执行的时候出了一点小问题，则执行回滚，之后这套事务中的所有操作将整体无效。</p><p>下面代码中，利用事务循环向数据库中添加2000条数据，假如在添加的过程中出现了一些问题，由于执行了<code class="language-plaintext highlighter-rouge">*rollback = YES</code>的回滚操作，数据库中一个数据都不会出现。 如果第2000条数据的添加出了问题，哪怕之前已经添加了1999条数据，由于执行了回滚，数据库中依然一个数据都没有。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre>// 数据库路径
NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
NSString *filePath = [path stringByAppendingPathComponent:@"student.sqlite"];

// 初始化FMDatabaseQueue
FMDatabaseQueue *dbQueue = [FMDatabaseQueue databaseQueueWithPath:filePath];

// FMDatabaseQueue的事务inTransaction
[dbQueue inTransaction:^(FMDatabase * _Nonnull db, BOOL * _Nonnull rollback) {
        // 创建表
        [db executeUpdate:@"create table if not exists t_student (id integer primary key autoincrement, name text, age integer)"];
        // 循环添加2000条数据
        for (int i = 0; i &lt; 2000; i++) {
            BOOL success = [db executeUpdate:@"insert into t_student(name,age) values(?,?)",@"jack",@(i)];
            // 如果添加数据出现问题，则回滚
            if (!success) {
                // 数据回滚
                *rollback = YES;
                return;
            }
        }
    }];
</pre></table></code></div></div><h1 id="core-data">Core Data</h1><p>Core Data有着图形化的操作界面，并且是操作模型数据的，更加面向对象。</p><p>利用Core Data快速实现数据存储</p><h2 id="1-图形化创建模型">1. 图形化创建模型</h2><p>创建项目的时候，勾选下图中的Use Core Data选项，工程中会自动创建一个数据模型文件。当然，你也可以在开发中自己手动创建。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%20-%20Use%20Core%20Data.png" alt="" /></p><p>下图就是自动创建出来的文件：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%20-%20CoreDataTest.png" alt="" /></p><p>如果没有勾选，也可以在这里手动创建。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%20-%20Data%20Model.png" alt="" /></p><p>点击Add Entity之后，相当一张数据表。表的名称自己在上方定义，注意首字母要大写。 在界面中还可以为数据实体添加属性和关联属性。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%20-%20Add%20Entity.png" alt="" /></p><p>Core Data属性支持的数据类型如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%20-%20Core%20Data%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="" /></p><p>编译之后，Xcode会自动生成Person的实体代码文件，并且文件不会显示在工程中，如果下图中右侧Codegen选择Manual/None,则Xcode就不会自动生成代码，我们可以自己手动生成。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%20-%20Core%20Data%20Codegen.png" alt="" /></p><p>手动生成实体类代码，选中CoreDataTest.xcdatamodeld文件，然后在Mac菜单栏中选择Editor，如下图所示。一路Next就可以了。 如果没有选择Manual/None，依然进行手动创建的话，则会与系统自动创建的文件发生冲突，这点需要注意。 你也可以不要选择Manual/None，直接使用系统创建好的NSManagedObject，同样会有4个文件，只是在工程中是看不到的，使用的时候直接导入<code class="language-plaintext highlighter-rouge">#import "Person+CoreDataClass.h"</code>头文件就可以了。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%20-%20Core%20Data%20Create%20NSManagedObject.png" alt="" /></p><p>手动创建出来的是这样4个文件。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%20-%20Core%20Data%20Create%20%E6%96%87%E4%BB%B6.png" alt="" /></p><p>还要注意编程语言的选择，Swift或OC。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%20-%20Core%20Data%20Create%20Swift%20OC.png" alt="" /></p><h2 id="2-core-data堆栈的介绍与使用">2. Core Data堆栈的介绍与使用</h2><p>下面要做的就是对Core Data进行初始化，实现本地数据的保存。 需要用到的类有三个：</p><ul><li>NSManagedObjectModel 数据模型的结构信息<li>NSPersistentStoreCoordinator 数据持久层和对象模型协调器<li>NSManagedObjectContext 对象的上下文managedObject 模型</ul><p>如下图所示，一个context内可以有多个模型对象，不过在大多数的操作中只存在一个context，并且所有的对象存在于那个context中。 对象和他们的context是相关联的，每个被管理的对象都知道自己属于哪个context，每个context都知道自己管理着哪些对象。</p><p>Core Data从系统读或写的时候，有一个持久化存储协调器(persistent store coordinator)，并且这个协调器在文件系统中与SQLite数据库交互，也连接着存放模型的上下文Context。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%20-%20persistent%20store%20coordinator.png" alt="" /></p><p>下图是比较常用的方式：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%20-%20Core%20Data%20%E5%B8%B8%E8%A7%81%20persistent%20store%20coordinator.png" alt="" /></p><p>下面我们来一步步实现Core Data堆栈的创建。</p><ul><li>首先在AppDelegate中定义一个NSManagedObjectModel属性。然后利用懒加载来创建NSManagedObjectModel对象。并且要注意创建时候的后缀用momd，代码如下：</ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>// 创建属性
@property (nonatomic, readwrite, strong) NSManagedObjectModel *managedObjectModel;

// 懒加载
- (NSManagedObjectModel *)managedObjectModel {
    if (!_managedObjectModel) {
        // 注意扩展名为 momd
        NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@"CoreDataTest" withExtension:@"momd"];
        _managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL];
    }
    return _managedObjectModel;
}
</pre></table></code></div></div><ul><li>创建协调器NSPersistentStoreCoordinator，同样的先在AppDelegate中来一个属性，然后懒加载。</ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre>// 属性
@property (nonatomic, readwrite, strong) NSPersistentStoreCoordinator *persistentStoreCoordinator;

// 懒加载
- (NSPersistentStoreCoordinator *)persistentStoreCoordinator {
    if (!_persistentStoreCoordinator) {
        // 传入之前创建好了的Model
        _persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:self.managedObjectModel];
        // 指定sqlite数据库文件
        NSURL *sqliteURL = [[self documentDirectoryURL] URLByAppendingPathComponent:@"CoreDataTest.sqlite"];
        // 这个options是为了进行数据迁移用的，有兴趣的可以去研究一下。
        NSDictionary *options=@{NSMigratePersistentStoresAutomaticallyOption:@(YES),NSInferMappingModelAutomaticallyOption:@(YES)};
        NSError *error;
        [_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType
                                                  configuration:nil
                                                            URL:sqliteURL
                                                        options:options
                                                          error:&amp;error];
        if (error) {
            NSLog(@"创建协调器失败： %@", error.localizedDescription);
        }
    }
    return _persistentStoreCoordinator;
}

// 获取document目录
- (nullable NSURL *)documentDirectoryURL {
    return [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask].firstObject;
}
</pre></table></code></div></div><ul><li>创建NSManagedObjectContext，同样的是属性+懒加载。</ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>// 属性
@property (nonatomic, readwrite, strong) NSManagedObjectContext *context;

// 懒加载
- (NSManagedObjectContext *)context {
    if (!_context) {
        _context = [[NSManagedObjectContext alloc ] initWithConcurrencyType:NSMainQueueConcurrencyType];
        // 指定协调器
        _context.persistentStoreCoordinator = self.persistentStoreCoordinator;
    }
    return _context;
}
</pre></table></code></div></div><h2 id="3-运用core-data对数据进行增删改查">3. 运用Core Data对数据进行增删改查</h2><h3 id="添加数据">添加数据</h3><p>使用NSEntityDesctiption类的一个方法创建NSManagedObject对象。参数一是实体类的名字，参数二是之前创建的Context。 为对象赋值，然后存储。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre>@implementation ViewController {
    NSManagedObjectContext *context;
}

- (void)viewDidLoad {
    [super viewDidLoad];
    // 拿到managedObjectContext
    context = [AppDelegate new].context;
    // 运用NSEntityDescription创建NSManagedObject对象
    Person *person = [NSEntityDescription insertNewObjectForEntityForName:@"Person" inManagedObjectContext:context];
    // 为对象赋值
    person.name = @"Jack";
    person.age = 17;
    NSError *error;
    // 保存到数据库
    [context save:&amp;error];
}
</pre></table></code></div></div><h3 id="查询数据">查询数据</h3><p>Core Data从数据库中查询数据，会用到三个类：</p><ul><li>NSFetchRequest：一条查询请求，相当于 SQL 中的select语句<li>NSPredicate：谓词，指定一些查询条件，相当于 SQL 中的where<li>NSSortDescriptor：指定排序规则，相当于 SQL 中的 order by</ul><p>NSFetchRequest中有两个属性：</p><ul><li>predicate：是NSPredicate对象<li>sortDescriptors：它是一个NSSortDescriptor数组，数组中前面的优先级比后面高。可以有多个排列规则。<li>fetchLimit：结果集最大数，相当于 SQL 中的limit<li>fetchOffset：查询的偏移量，默认为0<li>fetchBatchSize：分批处理查询的大小，查询分批返回结果集<li>entityName/entity：数据表名，相当于 SQL中的from<li>propertiesToGroupBy：分组规则，相当于 SQL 中的group by<li>propertiesToFetch：定义要查询的字段，默认查询全部字段</ul><p>设置好NSFetchRequest之后，调用NSManagedObjectContext的executeFetchRequest方法，就会返回结果集了。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>    // Xcode自动创建的NSManagedObject会生成fetchRequest方法，可以直接得到NSFetchRequest
    NSFetchRequest *fetchRequest = [Person fetchRequest];
    // 也可以这样获得：[NSFetchRequest fetchRequestWithEntityName:@"Student"];
    // 谓词
    fetchRequest.predicate = [NSPredicate predicateWithFormat:@"age == %@", @(16)];
    // 排序
    NSArray&lt;NSSortDescriptor *&gt; *sortDescriptors = @[[NSSortDescriptor sortDescriptorWithKey:@"age" ascending:YES]];
    fetchRequest.sortDescriptors = sortDescriptors;
    // 运用executeFetchRequest方法得到结果集
    NSArray&lt;Person *&gt; *personResult = [context executeFetchRequest:fetchRequest error:nil];
</pre></table></code></div></div><p>Xcode自己有一个NSFetchRequest的code snippet，“fetch”出现的结果如下图。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%20-Core%20Data%20NSFetchRequest.png" alt="" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%20-%20Core%20Data%20NSFetchRequest%20%E4%BB%A3%E7%A0%81.png" alt="" /></p><h3 id="更新数据">更新数据</h3><p>更新数据比较简单，查询出来需要修改的数据之后，直接修改值，然后用<code class="language-plaintext highlighter-rouge">context save:</code>就可以了。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>for (Person *person in personResult) {
    // 直接修改
    person.age = 26;
}
// 别忘了save一下
[context save:&amp;error];
</pre></table></code></div></div><h3 id="删除数据">删除数据</h3><p>查询出来需要删除的数据之后，调用 NSManagedObjectContext 的<code class="language-plaintext highlighter-rouge">deleteObject</code>方法就可以了。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>for (Person *person in personResult) {
    // 删除数据
    [context deleteObject:person];
}
// 别忘了save
[context save:&amp;error];
</pre></table></code></div></div><h1 id="参考文章">参考文章</h1><p><a href="https://www.fivehow.com/ios/2017-09-28-iOS数据存储.html">iOS 数据存储</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/ios/'>iOS</a>, <a href='/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/'>数据存储</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/objective-c/" class="post-tag no-text-decoration" >Objective-C</a> <a href="/tags/sqlite/" class="post-tag no-text-decoration" >SQLite</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=iOS 本地数据存储 - Ouyang Rong&url=https://ouyangrong.com/posts/iOS-Data-Storage/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=iOS 本地数据存储 - Ouyang Rong&u=https://ouyangrong.com/posts/iOS-Data-Storage/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=iOS 本地数据存储 - Ouyang Rong&url=https://ouyangrong.com/posts/iOS-Data-Storage/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/AnnualSummary-2023/">2023 年度总结</a><li><a href="/posts/AnnualSummary-2022/">2022 年度总结</a><li><a href="/posts/Source-Analysis-SDWebImage/">iOS SDWebImage 源码分析</a><li><a href="/posts/Source-Analysis-AFNetworking/">AFNetworking 源码分析</a><li><a href="/posts/architecture-design/">iOS 架构设计</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/gcd/">GCD</a> <a class="post-tag" href="/tags/objective-c/">Objective-C</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a> <a class="post-tag" href="/tags/afnetworking/">AFNetworking</a> <a class="post-tag" href="/tags/%E5%A4%A7%E5%8F%B7/">大号</a> <a class="post-tag" href="/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">年度总结</a> <a class="post-tag" href="/tags/%E6%80%BB%E7%BB%93/">总结</a> <a class="post-tag" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a> <a class="post-tag" href="/tags/arc/">ARC</a> <a class="post-tag" href="/tags/fmdb/">FMDB</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/iOS-Runtime-Summary/"><div class="card-body"> <span class="timeago small" > Oct 27, 2021 <i class="unloaded">2021-10-27T18:11:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Objective-C - Runtime 总结梳理</h3><div class="text-muted small"><p> Runtime的特性主要是消息(方法)传递，如果消息(方法)在对象中找不到，就进行转发，具体怎么实现的呢。我们从下面几个方面探寻Runtime的实现机制。 Runtime介绍 Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和编译语言写的 Runtime 库。它是 Objective-C 面向对象和动态...</p></div></div></a></div><div class="card"> <a href="/posts/iOS-Runloop-Summary/"><div class="card-body"> <span class="timeago small" > Nov 10, 2021 <i class="unloaded">2021-11-10T18:11:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Runloop 总结梳理</h3><div class="text-muted small"><p> RunLoop概念 RunLoop介绍 RunLoop 是什么？RunLoop 顾名思义就是一种循环，只不过它这种循环比较高级。一般的 while 循环会导致 CPU 进入忙等待状态，而 RunLoop 则是一种“闲”等待，这部分可以类比 Linux 下的 epoll。当没有事件时，RunLoop 会进入休眠状态；当有事件发生时，RunLoop 会去找对应的 Handler 处理事件...</p></div></div></a></div><div class="card"> <a href="/posts/iOS-YYKit-CodeLearn/"><div class="card-body"> <span class="timeago small" > Jan 7, 2022 <i class="unloaded">2022-01-07T18:11:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>iOS YYKit 源码学习</h3><div class="text-muted small"><p> YYKit 框架的作者是现任职于滴滴的郭曜源（ibireme）。 最近一系列开源项目 YYKit 在 iOS 社区引起广泛反响，由于其代码质量高，在短时间内就收获了大量的 star，它的作者是国人开发者 ibireme，优酷土豆的 iOS 开发工程师郭曜源，InfoQ 社区编辑唐巧对他进行了采访，了解这些开源项目背后的故事。 大家好，我叫郭曜源，是一个 iOS 开发者，现居北京，...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/iOS-Runloop-Summary/" class="btn btn-outline-primary" prompt="Older"><p>Runloop 总结梳理</p></a> <a href="/posts/iOS-YYKit-CodeLearn/" class="btn btn-outline-primary" prompt="Newer"><p>iOS YYKit 源码学习</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//ouyangrong-1.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'iOS 本地数据存储'; this.page.url = 'https://ouyangrong.com/posts/iOS-Data-Storage/'; this.page.identifier = '/posts/iOS-Data-Storage/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/ouyangrong1313">Ouyang Rong</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/gcd/">GCD</a> <a class="post-tag" href="/tags/objective-c/">Objective C</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a> <a class="post-tag" href="/tags/afnetworking/">AFNetworking</a> <a class="post-tag" href="/tags/%E5%A4%A7%E5%8F%B7/">大号</a> <a class="post-tag" href="/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">年度总结</a> <a class="post-tag" href="/tags/%E6%80%BB%E7%BB%93/">总结</a> <a class="post-tag" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a> <a class="post-tag" href="/tags/arc/">ARC</a> <a class="post-tag" href="/tags/fmdb/">FMDB</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://ouyangrong.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
