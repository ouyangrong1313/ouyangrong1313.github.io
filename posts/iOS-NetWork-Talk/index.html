<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="网络漫谈" /><meta name="author" content="Ouyang Rong" /><meta property="og:locale" content="en_US" /><meta name="description" content="HTTP 协议" /><meta property="og:description" content="HTTP 协议" /><link rel="canonical" href="https://ouyangrong.com/posts/iOS-NetWork-Talk/" /><meta property="og:url" content="https://ouyangrong.com/posts/iOS-NetWork-Talk/" /><meta property="og:site_name" content="Ouyang Rong" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-02-15T18:11:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="网络漫谈" /><meta name="twitter:site" content="@ouyangrong1313" /><meta name="twitter:creator" content="@Ouyang Rong" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Ouyang Rong"},"dateModified":"2022-02-15T18:42:48+08:00","datePublished":"2022-02-15T18:11:00+08:00","description":"HTTP 协议","headline":"网络漫谈","mainEntityOfPage":{"@type":"WebPage","@id":"https://ouyangrong.com/posts/iOS-NetWork-Talk/"},"url":"https://ouyangrong.com/posts/iOS-NetWork-Talk/"}</script><title>网络漫谈 | Ouyang Rong</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Ouyang Rong"><meta name="application-name" content="Ouyang Rong"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-4EXCTKYR2M"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-4EXCTKYR2M'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/images/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Ouyang Rong</a></div><div class="site-subtitle font-italic">Stay Hungry, Stay Foolish.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/ouyangrong1313" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/ouyangrong1313" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['951607559','qq.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>网络漫谈</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>网络漫谈</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Ouyang Rong </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Feb 15, 2022, 6:11 PM +0800" prep="on" > Feb 15, 2022 <i class="unloaded">2022-02-15T18:11:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, Feb 15, 2022, 6:42 PM +0800" prefix="Updated " > Feb 15, 2022 <i class="unloaded">2022-02-15T18:42:48+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7685 words">42 min</span></div></div><div class="post-content"><h1 id="http-协议">HTTP 协议</h1><h2 id="1-http-特性">1. HTTP 特性</h2><ul><li><code class="language-plaintext highlighter-rouge">HTTP</code> 协议构建于 <code class="language-plaintext highlighter-rouge">TCP/IP</code> 协议之上，是一个应用层协议，默认端口号是 <code class="language-plaintext highlighter-rouge">80</code>。<li><code class="language-plaintext highlighter-rouge">HTTP</code> 是无连接无状态的。</ul><h2 id="2-http-报文">2. HTTP 报文</h2><p><code class="language-plaintext highlighter-rouge">HTTP</code> 协议是以 ASCII 码进行传输的，建立在 <code class="language-plaintext highlighter-rouge">TCP/IP</code> 协议上的应用层规范。规范把 <code class="language-plaintext highlighter-rouge">HTTP</code> 分为三个部分：状态行、请求头、请求主体。HTTP 定义了与服务器交互的不同方法，常用的有如下四种：<code class="language-plaintext highlighter-rouge">GET</code> 、<code class="language-plaintext highlighter-rouge">POST</code> 、<code class="language-plaintext highlighter-rouge">DELETE</code> 、<code class="language-plaintext highlighter-rouge">PUT</code>。</p><p>URL 全称是资源描述符，一个 URL 地址用于描述一个网络上的资源，而 HTTP 中的 <code class="language-plaintext highlighter-rouge">POST</code>、<code class="language-plaintext highlighter-rouge">DELETE</code>、<code class="language-plaintext highlighter-rouge">PUT</code>、<code class="language-plaintext highlighter-rouge">GET</code> 就对应着对这个资源的 增、删、改、查 四个操作。其他请求方式还有：<code class="language-plaintext highlighter-rouge">HEAD</code> 、 <code class="language-plaintext highlighter-rouge">OPTIONS</code> 、 <code class="language-plaintext highlighter-rouge">TRACE</code> 、 <code class="language-plaintext highlighter-rouge">PATCH</code> 。</p><ul><li><code class="language-plaintext highlighter-rouge">GET</code> 用于信息的获取。（安全和幂等）注：安全意味着该操作用于获取信息而非修改信息。幂等意味着对同一 URL 的多个请求应返回同样的结果。<li><code class="language-plaintext highlighter-rouge">POST</code> 表示可能修改服务器上的资源的请求。(非安全、非幂等)<li><code class="language-plaintext highlighter-rouge">HEAD</code> 与 <code class="language-plaintext highlighter-rouge">GET</code> 方法类似，但不返回 message body内容，仅仅是获得获取资源的部分信息（content-type、content-length）(安全和幂等)<li><code class="language-plaintext highlighter-rouge">PUT</code> 用于创建、更新资源。（非安全、幂等）<li><code class="language-plaintext highlighter-rouge">DELETE</code> 删除资源。（非安全、幂等）<li><code class="language-plaintext highlighter-rouge">OPTIONS</code> 用于 URL 验证，验证接口服务是否正常。（安全、幂等）<li><code class="language-plaintext highlighter-rouge">TEACE</code> 回显服务器收到的请求，这样客户端可以看到（如果有）哪一些改变或者添加已经被中间服务器实现.（安全、幂等）<li><code class="language-plaintext highlighter-rouge">PATCH</code> 用于创建、更新资源，于PUT类似，区别在于PATCH代表部分更新；后来提出的接口方法，使用时可能去要验证客户端和服务端是否支持；（非安全、幂等）</ul><p><code class="language-plaintext highlighter-rouge">GET</code> 提交的数据量受 URL 长度的限制，HTTP 协议没有对 URL 长度进行限制，这个限制是浏览器和服务器对他的限制；理论上 <code class="language-plaintext highlighter-rouge">POST</code> 也是没有大小限制的，HTTP 协议也没有进行大小限制，出于安全考虑，服务器会做一定的限制。</p><h2 id="3-post-提交数据的方式">3. POST 提交数据的方式</h2><p>HTTP 协议中规定 POST 提交的数据必须在 Body 部分中，但协议并未规定数据需要采用何种数据格式或编码方式，服务端通常通过请求头中的 <code class="language-plaintext highlighter-rouge">Content-Type</code> 字段来获知请求中的消息主体是以何种方式编码，再对主体进行解析。</p><p>POST 提交数据的方案，包含：<code class="language-plaintext highlighter-rouge">Content-Type</code> 和消息主体编码方式两部分：</p><ul><li><code class="language-plaintext highlighter-rouge">application/x-www-form-urlencoded</code> ：最常见的 <code class="language-plaintext highlighter-rouge">POST</code> 数据提交方式，浏览器的原生。 表单，如果不设置 <code class="language-plaintext highlighter-rouge">enctype</code> 属性，最终就会以 <code class="language-plaintext highlighter-rouge">application/x-www-form-urlencoded</code> 方式提交数据。<li><code class="language-plaintext highlighter-rouge">multipart/form-data</code> ：使用表单上传文件时，必须让表单的 <code class="language-plaintext highlighter-rouge">enctype</code> 等于 <code class="language-plaintext highlighter-rouge">multipart/form-data</code> 。这种方式一般用于上传文件。<li><code class="language-plaintext highlighter-rouge">application/json</code><li><code class="language-plaintext highlighter-rouge">text/xml</code><li><code class="language-plaintext highlighter-rouge">application/x-protobuf</code></ul><p>只要服务器可以根据 <code class="language-plaintext highlighter-rouge">Content-Type</code> 和 <code class="language-plaintext highlighter-rouge">Content-Encoding</code> 正确解析出请求即可。</p><h2 id="4-响应报文">4. 响应报文</h2><p>HTTP 响应跟 HTTP 请求类似，也是由三部分构成：状态行、响应头、响应正文。 状态行由协议版本、数字形式的状态代码、响应的状态描述构成，各元素以空格分割。常见的状态码：</p><ul><li><code class="language-plaintext highlighter-rouge">200 OK</code> 客户端请求成功<li><code class="language-plaintext highlighter-rouge">301 Moved Permanently</code> 请求永久重定向<li><code class="language-plaintext highlighter-rouge">302 Moved Temporarily</code> 请求临时重定向<li><code class="language-plaintext highlighter-rouge">304 Not Modified</code> 文件未修改，可以直接使用缓存文件<li><code class="language-plaintext highlighter-rouge">400 Bad Request</code> 由于客户端请求有语法错误，无法被服务器所理解<li><code class="language-plaintext highlighter-rouge">401 Unauthorized</code> 请求未经授权（状态代码必须和WWW-Authenticate报头域一起使用）<li><code class="language-plaintext highlighter-rouge">403 Forbidden</code> 服务器收到请求，但拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。<li><code class="language-plaintext highlighter-rouge">404 Not Found</code> 请求的资源不存在。<li><code class="language-plaintext highlighter-rouge">500 Internal Server Error</code> 服务器发生不可预知的错误，导致无法完成客户端的请求。<li><code class="language-plaintext highlighter-rouge">503 Service Unavailable</code> 服务器当前不可处理客户端的请求，在一段时间后服务器可能会恢复正常。</ul><h2 id="5-条件-get">5. 条件 GET</h2><p><code class="language-plaintext highlighter-rouge">HTTP</code> 条件 <code class="language-plaintext highlighter-rouge">GET</code> 是 <code class="language-plaintext highlighter-rouge">HTTP</code> 协议为了减少不必要的宽带浪费，提出的一种方案。</p><ul><li>使用时机：客户端之前已经访问过该网站，并想再次访问。<li>使用方法：客户端向服务端发送一个包询问是否在上次访问网站后的时间后更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，</ul><p>客户端只需要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。</p><h2 id="6-持久连接">6. 持久连接</h2><p>一般情况下，<code class="language-plaintext highlighter-rouge">HTTP</code> 协议采用“请求-应答”模式，当使用普通模式，即非 <code class="language-plaintext highlighter-rouge">Keep-Alive</code> 模式时，每个请求/应答客户端和服务器都要新建一个连接，完成之后立即断开连接（<code class="language-plaintext highlighter-rouge">HTTP</code> 协议为无连接的协议）；当使用 <code class="language-plaintext highlighter-rouge">Keep-Alive</code> 模式（又称持久连接、连接重用）时，<code class="language-plaintext highlighter-rouge">Keep-Alive</code> 功能使客户端到服务端的连接持续有效，当出现对服务器的后续请求时，<code class="language-plaintext highlighter-rouge">Keep-Alive</code> 功能避免了建立或者重新建立连接。</p><p>在 HTTP 1.0 中： 如果客户端浏览器支持 <code class="language-plaintext highlighter-rouge">Keep-Alive</code>，那么就在 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求头中添加一个字段 <code class="language-plaintext highlighter-rouge">Connection-Keep-Alive</code>。</p><p>在 HTTP 1.1 中：默认所有连接都被保持。</p><ul><li><code class="language-plaintext highlighter-rouge">HTTP</code> <code class="language-plaintext highlighter-rouge">Keep-Alive</code> 简单来说就是保持当前 <code class="language-plaintext highlighter-rouge">TCP</code> 连接，避免重新建立连接。<li><code class="language-plaintext highlighter-rouge">HTTP</code> 长连接不可能一直保持，例如 <code class="language-plaintext highlighter-rouge">Keep-Alive: timeout=5, max=100</code>，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开.<li><code class="language-plaintext highlighter-rouge">HTTP</code> 是一个无状态协议，这意味着每个请求都是独立的，<code class="language-plaintext highlighter-rouge">Keep-Alive</code> 没有改变这个结果，<code class="language-plaintext highlighter-rouge">Keep-Alive</code> 无法保证客户端和服务端的连接一定是活跃的，唯一能保证的是当连接被断开时将会收到一个通知。<li>使用长连接之后，客户端、服务端怎么知道本次传输结束呢？1. 判断传输数据是否达到了 <code class="language-plaintext highlighter-rouge">Content-Length</code> 指示的大小；2. 动态生成的文件没有 <code class="language-plaintext highlighter-rouge">Content-Length</code> ，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后有一个空 chunked 块，表明本次传输数据结束.</ul><h2 id="7-transform-encoding">7. Transform-Encoding</h2><p><code class="language-plaintext highlighter-rouge">Transform-Encoding</code> 是一个用来标明 HTTP 报文传输格式的头部值，当前的 HTTP 规范里只定义了一种传输格式 - <code class="language-plaintext highlighter-rouge">chunked</code>。</p><p>如果一个 HTTP 消息请求或应答消息的 <code class="language-plaintext highlighter-rouge">Transform-Encoding</code> 消息头的值是 chunked ，那么消息体由数量未定的块组成，并以最后一个大小为 0 的块为结束。</p><ul><li><code class="language-plaintext highlighter-rouge">chunked</code> 和 <code class="language-plaintext highlighter-rouge">multipart</code> 两个名词在意义上有类似的地方，不过在 HTTP 协议当中这两个概念则不是一个类别的。<code class="language-plaintext highlighter-rouge">multipart</code> 是一种 <code class="language-plaintext highlighter-rouge">Content-Type</code>，标示 HTTP 报文内容的类型，而 <code class="language-plaintext highlighter-rouge">chunked</code> 是一种传输格式，标示报头将以何种方式进行传输。<li><code class="language-plaintext highlighter-rouge">chunked</code> 传输不能事先知道传输内容的大小，只能靠最后的空 <code class="language-plaintext highlighter-rouge">chunked</code> 块来判断结束，所以对于下载请求，是无法知道下载进度的。<li><code class="language-plaintext highlighter-rouge">chunked</code> 优势在于服务端可以边生成内容边发送，无需事先知道全部内容。HTTP/2 是不支持 <code class="language-plaintext highlighter-rouge">Transfer-Encoding: chunked</code> 的，因为 HTTP/2 有自己的 streaming 传输方式：<code class="language-plaintext highlighter-rouge">Source：MDN - Transfer-Encoding</code>。</ul><h2 id="8-http-pipelining-http-管线化">8. HTTP Pipelining (HTTP 管线化)</h2><p>默认情况下，HTTP 协议中每个传输层连接只能承载一个 HTTP 请求和响应，浏览器会在收到上一个请求的响应之后再发送下一个请求。在使用持久连接的情况下，某个连接上消息的传递类似于： <code class="language-plaintext highlighter-rouge">请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 -&gt; 响应3</code>。</p><p>使用 HTTP Pipelining 是将多个 HTTP 请求打包传递的技术，在传送过程中无需等待服务端的回应，某个连接上消息的传递类似于：<code class="language-plaintext highlighter-rouge">请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3</code>。</p><ul><li>管线化机制通过持久连接（persistent connection）完成，仅 HTTP/1.1 支持此技术（HTTP/1.0不支持）。<li>只有 <code class="language-plaintext highlighter-rouge">GET</code> 和 <code class="language-plaintext highlighter-rouge">HEAD</code> 请求可以实现管线化，<code class="language-plaintext highlighter-rouge">POST</code> 则有所限制。<li>初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议。<li>管线化不会影响响应到来的顺序。<li>HTTP 1.1 要求服务端实现管线化，不要求服务端也对响应进行管线化处理，只要求对管线化请求不失败即可。<li>由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如 Chrome 和 Firefox 默认并未开启管线化支持。</ul><h2 id="9-会话跟踪">9. 会话跟踪</h2><h3 id="会话">会话</h3><p>客户端打开与服务端的连接发送请求到服务端响应客户端请求的全过程称之为会话。</p><h3 id="会话跟踪">会话跟踪</h3><p>会话跟踪是对同一个用户对服务器的连续的请求和接收响应的监视。</p><h3 id="为何需要会话跟踪">为何需要会话跟踪</h3><p>客户端跟服务端的通信如果是采用 HTTP 协议通信，而 HTTP 协议是无状态的，它无法保存用户的状态（信息），即一次响应后就断开了，下次请求需要重新连接，此时需要判断是否为同一个用户，所以需要会话跟踪技术实现这种需求。</p><h3 id="会话跟踪常用技术">会话跟踪常用技术</h3><ul><li>URL 重写</ul><p>URL（统一资源定位符）是Web 上特定界面的地址，URL 重写技术就是在 URL 结尾添加一个附加数据来标识该会话，把会话的 ID 通过 URL 传输给服务端，以便在服务端区分不同用户。</p><ul><li>隐藏表单域</ul><p>将会话 ID 添加到HTTP表单元素中提交到服务器，此表单元素客户端不可见。</p><ul><li>Cookie</ul><ol><li>Cookie 是服务端发送给客户端的一小段信息，客户端请求时可读取该信息发送到服务端，进而进行用户识别，对于客户端的每次请求，服务器会将 Cookie 下发到客户端，在客户端可以进行保存以便下一次使用。<li>Cookie 可存放在客户端内存中，称为临时 Cookie，客户端关闭即清除；另外可存放在磁盘中，成为永久 Cookie。</ol><ul><li>Session</ul><ol><li>每一个用户都有一个特定的 Session，各个用户之间不可共享，是每个用户独享的，在 Session 中可以存放信息。<li>在服务端会创建一个 Session 对象，产生一个 SessionID 来标示这个 Session 对象，然后将这个 SessionID 放入 Cookie 中发送给客户端，下一次访问时，SessionID 会再次发送给服务端，在服务端进行识别不同用户。<li>Session 的实现依赖于 Cookie，若 Cookie 被禁用，那么 Session 也将失效。</ol><h2 id="10-跨站攻击">10. 跨站攻击</h2><p><strong>CSRF（Cross-Site request forgery）- 伪造请求，冒充用户在站内的正常操作。</strong></p><p>如何防止 <code class="language-plaintext highlighter-rouge">CSRF</code> 跨站攻击：</p><ul><li><p>关键操作只接受 <code class="language-plaintext highlighter-rouge">POST</code> 请求</p><li><p>验证码</p></ul><p>使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了 <code class="language-plaintext highlighter-rouge">CSRF</code> 攻击。但是如果你在一个网站作出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时候使用。</p><ul><li>检测 <code class="language-plaintext highlighter-rouge">Referer</code></ul><p>比如你在论坛留言，那么不管你留言后重定向到哪里去了，之前的那个网址一定会包含留言的输入框，这个之前的网址就会保留在新页面头文件的 <code class="language-plaintext highlighter-rouge">Referer</code> 中, 通过检查 <code class="language-plaintext highlighter-rouge">Referer</code> 的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都能接受到 <code class="language-plaintext highlighter-rouge">Referer</code> 的值，所以 <code class="language-plaintext highlighter-rouge">Referer Check</code> 一般用于监控 <code class="language-plaintext highlighter-rouge">CSRF</code> 攻击的发生，而不用来抵御攻击。</p><ul><li>Token</ul><ol><li>对参数进行加密预防 <code class="language-plaintext highlighter-rouge">CSRF</code> 攻击。<li>添加一个新参数 Token，不知道 Token 是无法构造出合法的请求进行攻击的。<li>Token 使用时机：<blockquote><ol><li>Token 要足够随机<li>Token 是一次性的，即每次请求成功后都要更新 Token<li>Token 要注意保密性</ol></blockquote></ol><p><strong>XSS (Cross Site Scripting，跨站脚本攻击) - 是注入攻击的一种</strong></p><p>如何防御 XSS：</p><p>将用户的输入使用 HTML 解析库进行解析，获取其中的数据。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从白名单中拿取。</p><h1 id="http-over-ssltls">HTTP over SSL/TLS</h1><h2 id="1-https-基本过程">1. HTTPS 基本过程</h2><p>HTTPS 即 HTTP over SSL/TLS ，是一种在加密通道进行 HTTP 内容传输的协议。</p><p><strong>TLS 基本过程：</strong></p><ul><li>客户端发送一个 <code class="language-plaintext highlighter-rouge">ClientHello</code> 消息到服务端，消息中包含了它的 TLS （Transport Layer Security） 的版本、可用的加密算法和压缩算法。<li>服务端向客户端发送一个 <code class="language-plaintext highlighter-rouge">ServerHello</code> 消息，消息中包含了服务端 TLS 的版本，服务端所选择的加密算法和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥来加密接下来的握手过程，直到协商生成一个新的对称密钥。证书中还包含了该证书所应用的域名范围（Common Name，简称 CN），用于客户端验证身份。<li>客户端根据自己信任的 CA 列表验证服务端的证书是否可信，如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密他，这串随机数会被用于生成新的对称密钥。<li>服务端使用自己的私钥解密上面的随机数，然后使用这串随机数生成自己的对称主密钥。<li>客户端发送一个 <code class="language-plaintext highlighter-rouge">finished</code> 消息给服务端，使用对称密钥加密这次通信的一个散列值。<li>服务器生成自己的 Hash 值，然后解密客户端发来的信息，检查这两个值是否对应，如果对应就向客户端发送一个 <code class="language-plaintext highlighter-rouge">finished</code> 消息，也使用协商好的对称密钥加密。<li>从现在开始，接下来整个 TLS 会话都使用对称密钥加密，传输应用层（HTTP）内容。</ul><p>TLS 的完整过程需要三个算法（协议），密钥交互算法、对称加密算法、消息认证算法。</p><h2 id="2-tls-证书机制">2. TLS 证书机制</h2><p>HTTPS 过程中有一个很重要的步骤，就是服务器要有 CA 证书机构颁发的证书，客户端根据自己信任的 CA 列表验证服务器的身份。</p><p>现代浏览器中，证书的验证过程依赖于证书信任链：即一个证书需要依靠上一个证书来证明自己是可信的，最顶层的证书是根证书，拥有根证书的机构被称为 根 CA（一般操作系统自带）。</p><h2 id="3-中间人攻击">3. 中间人攻击</h2><p>所谓中间人攻击，指攻击者与通信的两端都建立独立的联系，并交换其所接受到的数据，使通信的双方都认为他们正在通过私密的连接直接与对方进行通话，事实上整个会话都会被攻击者完全控制。在中间人攻击中，攻击者可以拦截双方的通信并插入新的内容。</p><h3 id="ssl-剥离-问题">SSL 剥离 问题</h3><p>SSL 剥离即阻止用户使用 HTTPS 访问网站。由于并不是所有网站都只支持 HTTPS，大部分网站会同时支持 HTTP 和 HTTPS 两种协议。用户在访问网站时，也可能会在地址栏中输入 http:// 的地址，第一次的访问完全是明文的，这就给了攻击者可乘之机。通过攻击 DNS 响应，攻击者可以将自己变成中间人。</p><h3 id="hsts">HSTS</h3><p>用于强制浏览器使用 HTTPS 访问网站的一种机制。它的基本机制是在服务器返回的响应中，加上一个特殊的头部，指示浏览器对于此网站，强制使用 HTTPS 进行访问。 HSTS 有一个很明显的缺点，是需要等待第一个服务器的响应中的头部才能生效，但如果第一次访问该网站就被攻击呢？为了解决这个问题，浏览器中会带上一些网站的域名，被称为 HSTS preload list。对于在这个 list 的网站来说，直接强制使用 HTTPS。</p><h3 id="伪造证书攻击">伪造证书攻击</h3><p>HSTS 只解决了 SSL 剥离的问题，然而即使在全程使用 HTTPS 的情况下，我们仍然有可能被监听。 第一步是需要攻击 DNS 服务器。第二步是攻击者自己的证书需要被用户信任，这一步对于用户来说是很难控制的，需要证书颁发机构能够控制自己不滥发证书。</p><h3 id="hpkp">HPKP</h3><p>HPKP 技术是为了解决伪造证书攻击而诞生的。 HPKP（Public Key Pinning Extension for HTTP）在 HSTS 上更进一步，HPKP 直接在返回头中存储服务器的公钥指纹信息，一旦发现指纹和实际接受到的公钥有差异，浏览器就可以认为正在被攻击。 和 HSTS 类似，HPKP 也依赖于服务器的头部返回，不能解决第一次访问的问题，浏览器本身也会内置一些 HPKP 列表。</p><h1 id="tcp-协议">TCP 协议</h1><h2 id="1-tcp-的特征">1. TCP 的特征</h2><ul><li>TCP 提供一种面向连接的、可靠的字节流服务。<li>在一个 TCP 连接中，仅有两方进行彼此通信，广播和多播不能用于 TCP。<li>TCP 使用校验、确认和重传机制来保证可靠传输。<li>TCP 给数据分节进行排序，并使用累积确认和保证数据的顺序不变和非重复。<li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制。</ul><p>*注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能做到的是：如果有可能就把数据递送给对方，否则就通知用户（使用放弃重传并中断连接这一方式实现）。因此准确说 TCP 也不是 100% 可靠的协议，他所能提供的是数据的可靠递送或故障的可靠通知。 *</p><h2 id="2-三次握手与四次挥手">2. 三次握手与四次挥手</h2><h3 id="三次握手">三次握手</h3><p>所谓三次握手，是指建立一个 <code class="language-plaintext highlighter-rouge">TCP</code> 连接，客户端和服务端需要传送三个包。</p><p>三次握手的目的是连接服务器指定端口，建立 <code class="language-plaintext highlighter-rouge">TCP</code> 连接，并同步连接双方的序列号和确认号，交换 <code class="language-plaintext highlighter-rouge">TCP</code> 窗口大小信息，在 <code class="language-plaintext highlighter-rouge">socket</code> 编程中，客户端执行 <code class="language-plaintext highlighter-rouge">connect()</code> 触发三次握手。</p><ul><li>第一次握手：（SYN = 1，seq = x）</ul><ol><li>客户端发送一个 <code class="language-plaintext highlighter-rouge">TCP</code> 的 <code class="language-plaintext highlighter-rouge">SYN</code> 标志位置 1 的包，指明客户端需要连接的端口和初始序号 X, 保存在包头的序列号(Sequence Number)字段里。<li>发送完毕后，客户端进入 <code class="language-plaintext highlighter-rouge">SYN_SEND</code> 状态。</ol><ul><li>第二次握手：（SYN = 1，ACK = 1，seq = y，ACKnum = x + 1）</ul><ol><li>服务端发回确认包（ACK）应答，即 <code class="language-plaintext highlighter-rouge">SYN</code> 和 <code class="language-plaintext highlighter-rouge">ACK</code> 均为 1，服务端选择自己的 <code class="language-plaintext highlighter-rouge">ISN</code> 序号，放到 <code class="language-plaintext highlighter-rouge">seq</code> 域里，同时将确认序号(Acknowledgement Number)设置为客户的 <code class="language-plaintext highlighter-rouge">ISN</code> 加1，即 X+1。<li>发送完毕后，服务端进入 SYN_RCVD 状态。</ol><ul><li>第三次握手：（ACK = 1，ACKnum = y + 1）</ul><ol><li>客户端再次发送确认包（ACK），<code class="language-plaintext highlighter-rouge">SYN</code> 标志位为 0，<code class="language-plaintext highlighter-rouge">ACK</code> 标志位为 1，并且把服务端发送的 <code class="language-plaintext highlighter-rouge">ACK</code> 的序号字段 + 1。<li>发送完毕后，客户端进入 <code class="language-plaintext highlighter-rouge">ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code class="language-plaintext highlighter-rouge">ESTABLISHED</code> 状态，<code class="language-plaintext highlighter-rouge">TCP</code> 握手结束。</ol><p>三次握手示意图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="" /></p><h3 id="四次挥手">四次挥手</h3><p><code class="language-plaintext highlighter-rouge">TCP</code> 的拆除需要发送四个包，因此称为四次挥手，也叫改进的三次握手。客户端和服务端均可主动发起挥手动作，在 <code class="language-plaintext highlighter-rouge">socket</code> 编程中，任意一端执行 <code class="language-plaintext highlighter-rouge">close()</code> 即可产生挥手操作。</p><ul><li>第一次挥手：（FIN = 1，seq = x）</ul><ol><li>假设客户端想要关闭连接，客户端发送一个 <code class="language-plaintext highlighter-rouge">FIN</code> 标志位为 1 的包，表示自己没有数据可发送了，但仍可以接收数据。<li>发送完毕后，客户端进入 <code class="language-plaintext highlighter-rouge">FIN_WAIT_1</code> 状态。</ol><ul><li>第二次挥手：（ACK = 1，ACKnum = x + 1）</ul><ol><li>服务端确认客户端的 <code class="language-plaintext highlighter-rouge">FIN</code> 包，并发送一个确认包，表明自己接收到了客户端关闭连接的请求，但还没有准备好关闭连接。<li>发送完毕后，服务端进入 <code class="language-plaintext highlighter-rouge">CLOSE_WAIT</code> 状态，客户端接收到这个确认包后，进入 <code class="language-plaintext highlighter-rouge">FIN_WAIT_2</code> 状态，等待服务端关闭连接。</ol><ul><li>第三次挥手：（FIN = 1，seq = y）</ul><ol><li>服务端准备好关闭连接时，向客户端发送结束连接请求，<code class="language-plaintext highlighter-rouge">FIN</code> 置为 1。<li>发送完毕后，服务端进入 <code class="language-plaintext highlighter-rouge">LAST_ACK</code> 状态，等待来自客户端的最后一个 <code class="language-plaintext highlighter-rouge">ACK</code>。</ol><ul><li>第四次挥手：（ACK = 1，ACKnum = y + 1）</ul><ol><li>客户端接收到来自服务端的关闭请求，发送一个确认包，并进入 <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> 状态。等待可能出现的要求重传的 <code class="language-plaintext highlighter-rouge">ACK</code> 包。<li>服务端接收到这个确认包之后，关闭连接，进入 <code class="language-plaintext highlighter-rouge">CLOSED</code> 状态。<li>客户端等待了某个固定时间（两个最大段声明周期）之后，没有收到服务器端的 <code class="language-plaintext highlighter-rouge">ACK</code>，以为服务端已经正常关闭连接，于是自己也关闭连接，进入 <code class="language-plaintext highlighter-rouge">CLOSED</code> 状态。</ol><p>四次挥手示意图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://raw.githubusercontent.com/ouyangrong1313/MarkdownPhotos/master/img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="" /></p><h2 id="3-syn-攻击">3. SYN 攻击</h2><h3 id="什么是-syn-攻击">什么是 SYN 攻击？</h3><p>在三次握手过程中的第二次握手时，服务器发送 <code class="language-plaintext highlighter-rouge">SYN_ACK</code> 之后，收到客户端的 <code class="language-plaintext highlighter-rouge">ACK</code> 之前的 <code class="language-plaintext highlighter-rouge">TCP</code> 连接称为半连接。此时服务器处于 <code class="language-plaintext highlighter-rouge">SYN_RCVD</code> 状态，当收到 <code class="language-plaintext highlighter-rouge">ACK</code> 后，服务器才能转入 <code class="language-plaintext highlighter-rouge">ESTABLISHED</code> 状态。</p><p><code class="language-plaintext highlighter-rouge">SYN</code> 攻击指的是，”攻击客户端” 在短时间内伪造大量不存在的 <code class="language-plaintext highlighter-rouge">IP</code> 地址，向服务端不断地发送 <code class="language-plaintext highlighter-rouge">SYN</code> 包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 <code class="language-plaintext highlighter-rouge">SYN</code> 包将长时间占用未连接队列，正常的 <code class="language-plaintext highlighter-rouge">SYN</code> 请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p><p><strong><code class="language-plaintext highlighter-rouge">SYN</code> 攻击是一种典型的 <code class="language-plaintext highlighter-rouge">Dos/DDos</code> 攻击</strong></p><h3 id="如何检测-syn-攻击">如何检测 SYN 攻击？</h3><p>当服务器出现大量的半连接状态时，特别是源 <code class="language-plaintext highlighter-rouge">IP</code> 地址是随机的，基本可以断定这是一次 <code class="language-plaintext highlighter-rouge">SYN</code> 攻击。在 <code class="language-plaintext highlighter-rouge">Linux/Unix</code> 上可以使用系统自带的 <code class="language-plaintext highlighter-rouge">netstats</code> 命令来检测 <code class="language-plaintext highlighter-rouge">SYN</code> 攻击。</p><h3 id="如何防御-syn-攻击">如何防御 SYN 攻击?</h3><p><code class="language-plaintext highlighter-rouge">SYN</code> 攻击不能完全被阻止，除非将 <code class="language-plaintext highlighter-rouge">TCP</code> 协议重新设计。可以尽可能减轻 <code class="language-plaintext highlighter-rouge">SYN</code> 攻击的危害：</p><ul><li>缩短超时（SYN Timeout）时间<li>增加最大半连接数<li>过滤网关防护<li><code class="language-plaintext highlighter-rouge">SYN cookie</code> 技术</ul><h2 id="4-tcp-keepalive">4. TCP KeepAlive</h2><p>TCP 的连接，实际上是一种纯软件层面的概念，在物理层并没有“连接”这种概念。如果出现一些意外导致某端出现异常而另一端无法感知，一直维护着这个连接，长时间会导致非常多的半连接状态的 TCP 连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制来避免。</p><p>TCP KeepAlive 的基本原理：隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。</p><p>TCP KeepAlive 的局限：首先 TCP KeepAlive 检测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能在内核层级检测连接的存活与否，而连接的存活不一定代表服务可用，例如当一个服务器 CPU 占用 100% 已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。</p><h1 id="udp-协议">UDP 协议</h1><p><code class="language-plaintext highlighter-rouge">UDP</code> 是一个简单的传输层协议，和 <code class="language-plaintext highlighter-rouge">TCP</code> 相比，<code class="language-plaintext highlighter-rouge">UDP</code> 有如下几个显著的特性：</p><ul><li><code class="language-plaintext highlighter-rouge">UDP</code> 缺乏可靠性。<code class="language-plaintext highlighter-rouge">UDP</code> 本身不提供确认序列号、超时重传等机制。<code class="language-plaintext highlighter-rouge">UDP</code> 数据报可能在网络中被复制，被重新排序。即 <code class="language-plaintext highlighter-rouge">UDP</code> 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次。<li><code class="language-plaintext highlighter-rouge">UDP</code> 数据报是有长度的。每个 <code class="language-plaintext highlighter-rouge">UDP</code> 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 <code class="language-plaintext highlighter-rouge">TCP</code> 是一个字节流协议，没有任何协议上的记录边界。<li><code class="language-plaintext highlighter-rouge">UDP</code> 是无连接的。<code class="language-plaintext highlighter-rouge">UDP</code> 客户端和服务器之间不存在长期的关系，<code class="language-plaintext highlighter-rouge">UDP</code> 发送数据报之前也不需要经过握手创建连接的过程。<li><code class="language-plaintext highlighter-rouge">UDP</code> 支持多播和广播。</ul><h1 id="ip-协议">IP 协议</h1><p>IP 协议位于 TCP/IP 协议的第三层 - 网络层。与传输层协议相比，网络层的责任是提供点到点的服务，而传输层（TCP/UDP）则提供端到端的服务。</p><h2 id="1-网络-osi-的七层协议">1. 网络 OSI 的七层协议</h2><div class="table-wrapper"><table><thead><tr><th>~<th>~<tbody><tr><td>7<td>应用层<tr><td>6<td>表示层<tr><td>5<td>会话层<tr><td>4<td>传输层<tr><td>3<td>网络层<tr><td>2<td>数据链路层<tr><td>1<td>物理层</table></div><h2 id="2-ip-地址的分类">2. IP 地址的分类</h2><ul><li>A 类地址<li>B 类地址<li>C 类地址<li>D 类地址</ul><h2 id="3-广播与多播">3. 广播与多播</h2><p>广播与多播仅用于 UDP（TCP 是面向连接的）</p><h3 id="广播">广播</h3><p>一共有四种广播地址：</p><ol><li>受限的广播：受限的广播地址为 <code class="language-plaintext highlighter-rouge">255.255.255.255</code><li>指向网络的广播：主机号为全 <code class="language-plaintext highlighter-rouge">1</code> 的地址<li>指向子网的广播<li>指向所有子网的广播</ol><h3 id="多播">多播</h3><p>又称组播，使用 D 类地址，D类地址分配的 28bit 均用作多播组号而不再表示其他</p><h3 id="bgp">BGP</h3><p>边界网关协议（BGP）是运行于 TCP 上的一种自治系统的路由协议</p><h1 id="socket-编程">Socket 编程</h1><h2 id="1-socket-基本概念">1. Socket 基本概念</h2><p><code class="language-plaintext highlighter-rouge">Socket</code> 是对 <code class="language-plaintext highlighter-rouge">TCP/IP</code> 协议族的一种封装，是应用层与 <code class="language-plaintext highlighter-rouge">TCP/IP</code> 协议族通信的中间软件抽象层。从设计模式的角度看，<code class="language-plaintext highlighter-rouge">Socket</code> 其实就是一个门面模式，它把复杂的 <code class="language-plaintext highlighter-rouge">TCP/IP</code> 协议族隐藏在 <code class="language-plaintext highlighter-rouge">Socket</code> 接口后面，对用户来说，一组简单的接口就是全部，让 <code class="language-plaintext highlighter-rouge">Socket</code> 去组织数据，以符合指定的协议。</p><p><code class="language-plaintext highlighter-rouge">Socket</code> 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（IP 地址、协议、端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其他进程进行交互。</p><p><code class="language-plaintext highlighter-rouge">Socket</code> 起源于 <code class="language-plaintext highlighter-rouge">Unix</code>，<code class="language-plaintext highlighter-rouge">Unix/Linux</code> 基本哲学之一就是：一切皆文件，都可以用“打开（open）-&gt; 读写（write/read）-&gt; 关闭（close）”模式来进行操作，因此 <code class="language-plaintext highlighter-rouge">Socket</code> 也被处理为一种特殊的文件。</p><h2 id="2-写一个简单的-webserver">2. 写一个简单的 WebServer</h2><p>一个简单的 Server 的流程包括：</p><ol><li>建立连接，接受一个客户端连接。<li>接受请求，从网络中读取一条 <code class="language-plaintext highlighter-rouge">HTTP</code> 请求报文。<li>处理请求，访问资源。<li>构建响应，创建带有 <code class="language-plaintext highlighter-rouge">header</code> 的 <code class="language-plaintext highlighter-rouge">HTTP</code> 响应报文。<li>发送响应，传给客户端。</ol><p>大体的程序与调用的函数逻辑：</p><ol><li><code class="language-plaintext highlighter-rouge">socket()</code> 创建套接字<li><code class="language-plaintext highlighter-rouge">bind()</code> 分配套接字地址<li><code class="language-plaintext highlighter-rouge">listen()</code> 等待连接请求<li><code class="language-plaintext highlighter-rouge">accept()</code> 允许连接请求<li><code class="language-plaintext highlighter-rouge">read()/write()</code> 数据交换<li><code class="language-plaintext highlighter-rouge">close()</code> 关闭连接</ol><h1 id="参考文章">参考文章</h1><p><a href="https://halfrost.com/https-begin/">HTTPS 温故知新（一）—— 开篇</a></p><p><a href="http://blog.cnbang.net/tech/3531/">移动 APP 网络优化概述</a></p><p><a href="https://qiuxuewei.com/post/wang-luo-shi-yi/">网络拾遗</a></p><p><a href="http://chuquan.me/2019/07/21/ios-network-nsurlsession/">iOS 网络(1) —— NSURLSession</a></p><p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html">iOS 应用架构谈 网络层设计方案</a></p><p><a href="https://xiaopengmonsters.github.io/2017/06/18/iOS应用架构谈：网络层框架的优化/">iOS 应用架构谈：网络层框架的优化</a></p><p><a href="https://bujige.net/blog/iOS-Resume-Download-NSURLConnection.html">iOS 网络：『文件下载、断点下载』的实现（一）：NSURLConnection</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/ios/'>iOS</a>, <a href='/categories/%E7%BD%91%E7%BB%9C/'>网络</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E7%BD%91%E7%BB%9C/" class="post-tag no-text-decoration" >网络</a> <a href="/tags/http/" class="post-tag no-text-decoration" >HTTP</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=网络漫谈 - Ouyang Rong&url=https://ouyangrong.com/posts/iOS-NetWork-Talk/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=网络漫谈 - Ouyang Rong&u=https://ouyangrong.com/posts/iOS-NetWork-Talk/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=网络漫谈 - Ouyang Rong&url=https://ouyangrong.com/posts/iOS-NetWork-Talk/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/AnnualSummary-2023/">2023 年度总结</a><li><a href="/posts/AnnualSummary-2022/">2022 年度总结</a><li><a href="/posts/Source-Analysis-SDWebImage/">iOS SDWebImage 源码分析</a><li><a href="/posts/Source-Analysis-AFNetworking/">AFNetworking 源码分析</a><li><a href="/posts/architecture-design/">iOS 架构设计</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/gcd/">GCD</a> <a class="post-tag" href="/tags/objective-c/">Objective-C</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a> <a class="post-tag" href="/tags/afnetworking/">AFNetworking</a> <a class="post-tag" href="/tags/%E5%A4%A7%E5%8F%B7/">大号</a> <a class="post-tag" href="/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">年度总结</a> <a class="post-tag" href="/tags/%E6%80%BB%E7%BB%93/">总结</a> <a class="post-tag" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a> <a class="post-tag" href="/tags/arc/">ARC</a> <a class="post-tag" href="/tags/fmdb/">FMDB</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Source-Analysis-AFNetworking/"><div class="card-body"> <span class="timeago small" > Aug 25, 2022 <i class="unloaded">2022-08-25T14:21:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>AFNetworking 源码分析</h3><div class="text-muted small"><p> 一、架构 AFNetworking 一共分为 5 个模块，2 个核心模块和 3 个辅助模块： Core NSURLSession（网络通信模块） AFURLSessionManager（封装 NSURLSession） AFHTTPSessionManager（继承自 AFURLSessionManager，实现了 HTTP 请求相关的配置） Serialization...</p></div></div></a></div><div class="card"> <a href="/posts/ios-network-request-optimize-multithreading/"><div class="card-body"> <span class="timeago small" > Jun 15, 2021 <i class="unloaded">2021-06-15T16:14:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>多线程 - 重复网络请求优化</h3><div class="text-muted small"><p> 问题分析 一个页面，可以通过点击不同的模块获取相应的数据。但是，当用户频繁点击的时候，有的模块网络请求数据返回会比较慢，这个时候返回的数据就会覆盖当前模块的数据。 解决方法 加锁处理 切换模块时，会对同一个API进行多次请求，但因为调用的接口都是一样的，所以最好就是加上锁，防止重复请求造成网络资源浪费。 @synchronized (self) {//加锁，避免数组重复创建添加等...</p></div></div></a></div><div class="card"> <a href="/posts/iOS-YYKit-CodeLearn/"><div class="card-body"> <span class="timeago small" > Jan 7, 2022 <i class="unloaded">2022-01-07T18:11:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>iOS YYKit 源码学习</h3><div class="text-muted small"><p> YYKit 框架的作者是现任职于滴滴的郭曜源（ibireme）。 最近一系列开源项目 YYKit 在 iOS 社区引起广泛反响，由于其代码质量高，在短时间内就收获了大量的 star，它的作者是国人开发者 ibireme，优酷土豆的 iOS 开发工程师郭曜源，InfoQ 社区编辑唐巧对他进行了采访，了解这些开源项目背后的故事。 大家好，我叫郭曜源，是一个 iOS 开发者，现居北京，...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/iOS-YYKit-CodeLearn/" class="btn btn-outline-primary" prompt="Older"><p>iOS YYKit 源码学习</p></a> <a href="/posts/AnnualSummary-2021/" class="btn btn-outline-primary" prompt="Newer"><p>2021 年度总结</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//ouyangrong-1.disqus.com/embed.js', disqusConfig: function() { this.page.title = '网络漫谈'; this.page.url = 'https://ouyangrong.com/posts/iOS-NetWork-Talk/'; this.page.identifier = '/posts/iOS-NetWork-Talk/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/ouyangrong1313">Ouyang Rong</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/gcd/">GCD</a> <a class="post-tag" href="/tags/objective-c/">Objective C</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a> <a class="post-tag" href="/tags/afnetworking/">AFNetworking</a> <a class="post-tag" href="/tags/%E5%A4%A7%E5%8F%B7/">大号</a> <a class="post-tag" href="/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">年度总结</a> <a class="post-tag" href="/tags/%E6%80%BB%E7%BB%93/">总结</a> <a class="post-tag" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a> <a class="post-tag" href="/tags/arc/">ARC</a> <a class="post-tag" href="/tags/fmdb/">FMDB</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://ouyangrong.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
